# 자료구조

### Array vs Linked List

--- 

##### Array

가장 기본적인 자료구조인 Array자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스(index)로 해당 원소(element)에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있다. 즉, random access가 가능하다는 장점이 있는 것이다.

하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)이 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complxity의 worst case는 O(n)이 된다. 삽입의 경우도 마찬가지이다. 만약 첫 번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 된다.

##### Linked List

앞 부분의 문제점을 해결하기 위한 자료구조가 linked list이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)만에 해결할 수 있는 것이다.

하지만 역시 한 가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 찾는 Search과정에 있어서 첫 번째 원소부터 다 확인해봐야 한다는 것이다. Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해 O(n)의 시간이 추가적으로 발생하게 된다.

결국 Linked list 자료구조는 Search에도 O(n)의 시간복잡도를 가지며, 삽입과 삭제에 대해서도 O(n)의 시간 복잡도를 갖는다. 아주 쓸모없는 자료구조는 아니기에 학습하는 것이다. 이 Linked list는 Tree구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때 그 유용성이 드러난다.

###### 해볼 것

- Array를 기반으로 한 Linked List 구현

- ArrayList를 기반으로 한 Linked List 구현

---

### Stack and Queue

##### Stack

선형 자료구조의 일종으로 Last In First Out(LIFO) - 나중에 들어간 원소가 먼저 나온다. 또는 First In Last Out(FILO) - 먼저 들어간 원소가 나중에 나온다. 이것은 Stack의 가장 큰 특징이다. 차곡차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조이다.

##### Queue

선형 자료구조의 일종으로 First In FIrst Out(FIFO). 즉, 먼저 들어간 원소가 먼저 나온다. Stack과는 반대로 먼저 들어간 원소가 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다. 

###### 해볼 것

- Stack을 사용하여 미로찾기 구현하기

- Queue를 사용하여 Heap 자료구조 구현하기

- Stack 두 개로 Queue자료구조 구현하기

- Stack으로 괄호 유효성 체크 코드 구현하기

---

### Tree


