# Django

## Framework 이해

- 누군가 만들어 놓은 코드를 재사용하는 것은 이미 익숙한 개발 문화
- 자주 사용되는 부분들을 재사용할 수 있게 좋은 구조의 코드로 만들어져 있다.
- 그러한 코드들을 모아 놓은 것, ****즉 서비스 개발에 필요한 기능들을 미리 구현해서 모아 놓은 것 = 프레임워크****
- “소프트웨어 프레임워크”는 복잡한 문제를 해결하거나 서술하는 데 사용되는 기본 개념 구조
- 소프트웨어의 생산성과 품질을 높인다.

## 클라이언트와 서버

### 클라이언트-서버 구조

- 오늘날 우리가 사용하는 대부분의 웹 서비스는 클라이언트-서버 구조를 기반으로 동작
- 클라이언트와 서버 역시 하나의 컴퓨터이다. 클라이언트는 서버에 요청(requests)하고 서브는 클라이언트에 응답(response)하는 상호작용을 한다.
- 클라이언트
    - 웹 사용자의 인터넷에 연결된 장치(ex. wi-fi에 연결된 컴퓨터 또는 모바일)
    - Chrome과 같은 웹 브라우저
    - **서비스를 요청하는 주체**
- 서버
    - 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터
    - 클라이언트가 웹 페이지에 접근하려고 할 때 서버에서 클라이언트 컴퓨터로 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시된다.
    - **요청에 대해 서비스를 응답하는 주체**
- 어떠한 자원(resource)를 달라고 요청(request)하는 쪽을 클라이언트라고 하고 자원을 제공해주는 쪽을 서버(server)라고 한다.

### 정리

- 우리가 사용하는 웹은 클라이언트-서버 구조로 이루어져 있다.
- Django는 서버를 구현하는 웹 프레임워크이다.

### Django Project

- 설치 : `pip install django==3.2.18`
- 프로젝트 생성 : `django-admin startproject [프로젝트 이름]`
- 서버 실행 : `python [manage.py](http://manage.py) runserver`
- 서버 실행 후 메인 페이지 확인 (ex. [http://127.0.0.1:8000/](http://127.0.0.1:8000/))

### 패키지와 가상환경

각각의 패키지를 하나의 환경에 담아야 한다면? ⇒ 가상환경!

<aside>
💡 **global에 설치하는 것보다는 가상환경을 많이 활용하자!**

</aside>

- 생성 : `python -m venv [venv 가상환경 이름 보통 venv 사용]`
- 활성화 : `source venv/Scripts/activate`
- 비활성화 : `deactivate`
- 가상환경 패키지 목록 저장 : `pip freeze > requirements.txt`
- 파일로부터 패키지 설치 : `pip install -r requirements.txt`

## 프로젝트와 앱

- 장고는 커다란 프로젝트 하나와 기능 단위의 여러 앱으로 이루어져 있다.

### 프로젝트 구조

- _ _init _ _.py
- asgi.py
- settings.py
    - Django 프로젝트 설정을 관리
- urls.py
    - 사이트의 url과 적절한 views의 연결을 지정
- wsgi.py
- manage.py
    - Django 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티

### Django Application

- 앱 생성 : `python [manage.py](http://manage.py) startapp articles` 앱 이름은 복수형으로 작성 권장
앱(App) == 하나의 큰 기능 단위
정해진 규칙은 없으며 개발자가 판단해서 앱 생성
여러 개의 앱이 아닌 단일 앱으로 개발해도 괜찮다.

### 앱 구조

- [admin.py](http://admin.py)
    - 관리자용 페이지를 설정하는 곳
- apps.py
- models.py
    - 앱에서 사용하는 Model(데이터 구조)을 정의하는 곳
    - MTV패턴의 M에 해당
- tests.py
- view.py
    - 앱의 로직을 적는 곳. view 함수들이 정의 되는 곳
    - MTV패턴의 V에 해당

### 앱 등록

<aside>
💡 **앱을 사용하기 위해서는 반드시 INSTALLED_APPS 리스트에 앱을 추가해야한다.**

</aside>

### Project & Application

- Project
    - collection of apps, 프로젝트는 앱의 집합
    - 프로젝트에는 여러 앱이 포함될 수 있다.
    - 앱은 여러 프로젝트에 있을 수 있다.
- Application
    - 앱은 실제 요청을 처리하고 페이지를 보여주는 등의 역할을 담당
    - 앱은 하나의 역할 및 기능 단위로 작성하는 것을 권장한다.

## 요청과 응답

### Django의 세가지 구조, MTV

- Model
- View
- Template ⇒ html!

### URLs

- URL → VIEW → TEMPLATE 데이터 흐름 이해하기

### View

- 실행시킬 함수를 적는 곳
- 요청이 들어오면 HTML Page로 응답을 돌려준다.

### Templates

- 실제 내용을 보여주는데 사용되는 파일
- 파일의 구조나 레이아웃을 정의
- Template 파일의 기본 경로
    - app 폴더 안의 templates 폴더
    - **app_name/templates/app_name**

<aside>
💡 **템플릿 폴더 이름은 반드시 templates로 지정.
app_name/templates/app_name 위치에 html생성**

</aside>

### render()

`render(request, template_name, context)`

- 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링된 텍스트와 함께 HttpResponse(응답) 객체를 반환하는 함수
1. request : 응답을 생성하는 데 사용되는 요청 객체
2. template_name : 템플릿의 전체 이름 또는 템플릿 이름의 경로
3. context : 템플릿에서 사용할 데이터 (딕셔너리 타입으로 작성)

### 코드 작성 순서

- 앞으로 Django에서의 코드 작성은 URL → View → Template순으로 작성(”데이터의 흐름 순서”)

```python
# settings
INSTALLED_APPS = []  # <= APP이름 추가
# URL
from APP_NAME import index
path('index/', views.index)
# View
def index(request):
    return render(request, 'index.html')
# Template 
# APP_NAME/templates/APP_NAME/index.html에 만들기
```

## Django 구조 이해하기(MTV Design Pattern)

### Design Pattern(SW 관점)

- 각기 다른 기능을 가진 다양한 응용 소프트웨어를 개발할 때 공통적인 설계 문제가 존재하며, 이를 처리하는 해결책 사이에도 공통점이 있다는 것을 발견. 이런 유사점을 패턴이라 한다.
- 클라이언트-서버 구조도 소프트웨어 디자인 패턴 중 하나이다. 목적은 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책을 제시하는 것이다.

<aside>
💡 다수의 엔지니어들이 일반화된 패턴으로 소프트웨어 개발을 할 수 있도록 한 규칙, 커뮤니케이션의 효율성을 높이는 기법

</aside>

## Django’s Design Pattern

- Django에 적용된 디자인 패턴은 **MTV패턴**이다.
- MTV패턴은 **MVC 디자인 패턴**을 기반으로 조금 변형된 패턴이다.

### MVC SW Design Pattern

- MVC는 Model - View - Controller의 준말이다. 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴
- 하나의 큰 프로그램을 세가지 역할로 구분한 개발 방법론
1. Model : 데이터와 관련된 로직을 관리
2. View : 레이아웃과 화면을 처리
3. Controller : 명령을 model과 view 부분으로 연결

### MVC SW Design Pattern 목적

- 관심사 분리
- 더 나은 업무의 분리와 향상된 관리 제공
- 각 부분을 독립적으로 개발 가능(하나씩 수정 가능) == 개발 효율성 및 유지보수가 쉬워짐 == 다수의 멤버로 개발하기 용이

### Django에서의 디자인 패턴

- Django는 MVC패턴을 기반으로 한 MTV패턴을 사용한다. 두 패턴은 서로 크게 다른 점은 없으며 역할에 대해 부르는 이름이 다르다.

| MVC | MTV |
| --- | --- |
| Model | Model |
| View | Template |
| Controller | View |

### MTV 디자인 패턴

- Model
    - MVC 패턴에서 Model의 역할에 해당
    - 데이터와 관련된 로직을 관리
    - 응용프로그램의 데이터 구조를 정의하고 데이터베이스의 기록을 관리
- Template
    - MVC 패턴에서 View의 역할에 해당
    - 레이아웃과 화면을 처리
    - 화면상의 사용자 인터페이스 구조와 레이아웃을 정의
- View
    - MVC 패턴에서 Controller의 역할에 해당
    - Model & Template과 관련한 로직을 처리해서 응답을 반환
    - 클라이언트의 요청에 대해 처리를 분기하는 역할
    - 예시 : 데이터가 필요하다면 model에 접근해서 데이터를 가져오고 가져온 데이터를 template로 보내 화면을 구성하고 구성된 화면을 응답으로 만들어 클라이언트에게 반환

### 정리

- Model : 데이터 관련
- Template : 화면 관련
- View : Model & Template 중간 처리 및 응답 반환

## Django Template

- 데이터 표현을 제어하는 도구이자 표현에 관련된 로직
- Django Template을 이용한 HTML 정적 부분과 동적 컨텐츠 삽입
- Template System의 기본 목표를 숙지
- Django Template System : 데이터 표현을 제어하는 도구이자 표현에 관련된 로직을 담당

### Django Template Language(DTL)

- Django template에서 사용하는 built-in template system
- 조건, 반복, 변수 치환, 필터 등의 기능을 제공
    - Python처럼 일부 프로그래밍 구조(if, for 등)를 사용할 수 있지만 이게 **Python 코드로 실행되는 것이 아니다.**
    - Django Template System은 단순히 python이 HTML에 포함된 것이 아니니 주의
- 프로그래밍적 로직이 아니라 프레젠테이션을 표현하기 위한 것임을 명심할 것

### DTL Syntax

1. Variable : 변수
2. Filters : 변수가 보여지는 걸 바꿔주는 것
3. Tags : 변수보다 복잡한 일
4. Comments : 주석

### Variable `{{variable}}`

- 변수명은 영어, 숫자와 밑줄(_)의 조합으로 구성될 수 있으나 밑줄로는 시작할 수 없다.(공백이나 구두점 문자도 불가)
- dot(.)를 사용하여 변수 속성에 접근할 수 있다.(리스트 인덱스 및 딕셔너리 키 값에 접근 가능)
- render()의 세 번째 인자로 {’key’:value}와 같이 딕셔너리 형태로 넘겨주며, 여기서 정의한 key에 해당하는 문자열이 template에서 사용 가능한 변수명이 된다.

### Filters `{{variable|filter}}`

- 표시할 변수를 수정할 때 사용(값이 바뀌는 게 아니다)
- 60개의 built-in template filters를 제공(공식문서 확인)
- chained가 가능하며 일부 필터는 콜론으로 인자를 받기도 한다.

### Tags `{% tag %}`

- 출력 텍스트를 만들거나, 반복 또는 논리를 수행하여 제어 흐름을 만드는 등 변수보다 복잡한 일들을 수행
- 일부 태그는 시작과 종료 태그가 필요 `{% if %}{% endif %}`
- 24개의 built-in template tags를 제공한다.

### Comments `{# #}`

- Django template에서 라인의 주석을 표현하기 위해 사용
- 한 줄 주석에만 사용할 수 있다.(줄 바꿈 X)
- 여러 줄 주석은 `{% comment %}`와 `{% endcomment %}` 사이에 입력

## Template inheritance

### 템플릿 상속

- 템플릿 상속은 기본적으로 코드의 재사용성에 초점을 맞춤
- 템플릿 상속을 사용하면 사이트의 모든 공통 요소를 포함하고, 하위 템플릿이 재정의(override)할 수 있는 블록을 정의하는 기본 ‘skeleton’ 템플릿을 만들 수 있음

### 템플릿 상속에 관련된 태그

`{% extends ‘’ %}`

- 자식(하위) 템플릿이 부모 템플릿을 확장한다는 것을 알림

<aside>
💡 반드시 템플릿 최상단에 작성 되어야 한다. 즉, 2개 이상 사용할 수 없다.

</aside>

`{% block content %}{% endblock content %}`

- 하위 템플릿에서 재지정(overridden)할 수 있는 블록을 정의
- 즉, 하위 템플릿이 채울 수 있는 공간

### Django의 Template 처리

- settings.py에서 TEMPLATES 리스트를 보면 `'APP_DIRS':True`로 app별로 디렉토리를 두는 것으로 되어 있다.
- `'DIRS':[]` 부분에 디렉토리를 적어주면, Django가 해당 디렉토리부터 확인한다. ⇒ 모든 앱에서 가져다 쓸 수 있다.

<aside>
💡 DIRS에 디렉토리를 적어주기 전에는 base.html이 app안의 templates이므로 
`{% extends './base.html' %]` 와 같이 적었지만 app의 템플릿에서 프로젝트의 템플릿으로 옮기면 `{% extends 'base.html' %]` 로 사용하면 된다.

</aside>

## Django URLs

### Trailing URL Slashes

- Django는 URL 끝에 /(Trailing slash)가 없다면 자동으로 붙여주는 것이 기본 설정이다.
    - 모든 주소가 ‘/’로 끝나도록 구성되어 있다.
    - 모든 프레임워크가 이렇게 동작하는 것은 아니다.
- Django의 url 설계 철학 [foo.com/bar](http://foo.com/bar) 와 [foo.com/bar/](http://foo.com/bar/는)는 서로 다른 URL이다.
    - 검색 엔진 로봇이나 웹 트래픽 분석 도구에서는 그 둘을 서로 다른 페이지로 본다.
    - 그래서 Django는 URL을 정규화하여 검색 엔진 로봇이 혼동하지 않게 해야한다.

### Variable routing

- 템플릿의 많은 부분이 중복되고, 일부분만 변경되는 상황에서 비슷한 URL과 template을 만드는 것을 방지하기 위해 필요하다.
- URL 주소를 변수로 사용하는 것을 의미
- URL의 일부를 변수로 지정하여 view 함수의 인자로 넘길 수 있다.
- 즉, 변수 값에 따라 하나의 path()에 여러 페이지를 연결시킬 수 있다.
- 변수는 ‘<>’안에 정의하며 view함수의 인자로 할당된다.
- 기본 타입은 string이며 5가지 타입으로 명시할 수 있다.
    1. str `urlpatterns=[path('hello/<str:name>/', views.hello),]`
        - ‘/’를 제외하고 비어 있지 않은 모든 문자열
        - 작성하지 않을 경우 기본 값
    2. int
        - 0 또는 양의 정수와 매치
    3. slug
    4. uuid
    5. path

### View 함수 작성

- variable routing으로 할당된 변수를 인자로 받고 템플릿 변수로 사용할 수 있다.

## App URL mapping

- App이 많아지면? 모두 프로젝트의 urls.py에서 관리하기 힘들고 가독성도 떨어진다.
- 같은 이름이 겹친다면 view함수를 as문법으로 다른 이름으로 import할 수 있겠지만 역시 많아질수록 비효율적이다.
- 간단하다, urls.py를 쪼개면 된다.
- 하나의 프로젝트에 여러 앱이 존재한다면, 각각의 앱 안에 urls.py를 만들고 프로젝트 urls.py에서 각 앱의 urls.py파일로 URL매핑을 위탁할 수 있다.
- **각각의 app 폴더 안에 urls.py를 작성한다.**

### Including other URLconfs

- urlpattern은 언제든지 다른 URLconf모듈을 포함(include)할 수 있다.

<aside>
💡 **include되는 앱의 urls.py에 urlpatterns가 작성되어 있지 않다면 에러가 발생한다. 예를 들어 pages 앱의 urlpatterns가 빈 리스트라도 작성되어 있어야 한다.**

</aside>

### include()

- 다른 URLconf(app/urls.py)들을 참조할 수 있도록 돕는 함수
- 함수 include()를 만나게 되면 URL의 그 시점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속 처리를 위해 include된 URLconf로 전달

## Naming URL patterns

- 만약 index/의 문자열 주소를 new-index/로 바꿔야 한다고 가정하자. index/ 주소를 사용했던 모든 곳을 찾아서 변경해야 하는 번거로움이 발생한다.

### Naming URL patterns

- 이제는 링크에 URL을 직접 작성하는 것이 아니라 path()함수의 name인자를 정의해서 사용한다.
- DTL의 Tag 중 하나인 URL 태그를 사용해서 path()함수에 작성한 name을 사용할 수 있다.
- 이를 통해 URL 설정에 정의된 특정한 경로들의 의존성을 제거할 수 있다.
- Django는 URL에 이름을 지정하는 방법을 제공함으로써 view함수와 템플릿에서 특정 주소를 쉽게 참조할 수 있도록 도움

### Built-in tag-”url” `{% url “” %}`

- 템플릿에서 사용하기
- 주어진 URL패턴 이름 및 선택적 매개 변수와 일치하는 절대 경로 주소를 반환
- 템플릿에 URL을 하드 코딩하지 않고도 DRY원칙을 위반하지 않으면서 링크를 출력하는 방법

### url태그 출력 확인하기

- 마지막으로 개발자 도구를 통해 url태그가 URL 패턴 이름과 일치하는 절대 경로 주소를 반환하는 것을 확인해보기

## URL namespace

- URL namespace를 사용하면 서로 다른 앱에서 동일한 URL 이름을 사용하는 경우에도 이름이 지정된 URL을 고유하게 사용할 수 있다.
- **app_name** attribute를 작성해 URL namespace를 설정

### URL tag의 변화

`{% url 'index' %}` ⇒ `{% url 'articles:index' %}`

위와 같이 “:”연산자를 사용하여 지정하는 것이 URL 참조이다.

### 기존 URL tag 변경

<aside>
💡 **app_name을 지정한 이후에는 url 태그에서 반드시 app_name:url_name 형태로만 사용해야 한다. 그렇지 않으면 NoReverseMatch에러가 발생한다.**

</aside>

## Form & Data

### Sending and Retrieving form data

- 데이터를 보내고 가져오기
- HTML form element를 통해 사용자와 애플리케이션 간의 상호작용 이해하기

### Client & Server architecture

- 웹은 기본적으로 클라이언트-서버 아키텍처를 사용한다. 클라이언트(일반적으로 웹 브라우저)가 서버에 요청을 보내고, 서버는 클라이언트의 요청에 응답
- 클라이언트 측에서 HTML  form은 HTTP요청을 서버에 보내는 가장 편리한 방법이다. 이를 통해 사용자는 HTTP요청에서 전달할 정보를 제공할 수 있다.

## Sending form data(Client)

- throw

### HTML <form> element

- 데이터가 전송되는 방법을 정의한다.
- 웹에서 사용자 정보를 입력하는 여러 방식(text, button, submit 등)을 제공하고, **사용자로부터 할당된 데이터를 서버로 전송**하는 역할을 담당
- 데이터를 어디(**action**)로 어떤 방식(**method**)으로 보낼지

### HTML form’s attributes

1. action
    - 입력 데이터가 전송될 URL을 지정
    - 데이터를 어디로 보낼 것인지 지정하는 것이며 이 값은 반드시 유효한 URL이어야 한다.
    - 만약 이 속성을 지정하지 않으면 데이터는 현재 form이 있는 페이지의 URL로 보내진다.
2. method
    - 데이터를 어떻게 보낼 것인지 정의
    - 입력 데이터의 HTTP request methods를 지정
    - HTML form 데이터는 오직 2가지 방법으로만 전송할 수 있는데 GET과 POST방식이다.

### HTML <input> element

- 사용자로부터 데이터를 입력받기 위해 사용
- type속성에 따라 동작 방식이 달라진다.
    - input요소의 동작 방식은 type특성에 따라 현격히 달라지므로 각각의 type은 별도로 mdn문서에서 참고하여 사용하도록 한다.
    - type을 지정하지 않은 경우, 기본값은 text
- 핵심 속성 : `name`

### HTML input’s attribute

- **name**
    - form을 통해 데이터를 제출(submit)했을 때 name속성에 설정된 값을 서버로 전송하고, 서버는 name속성에 설정된 값을 통해 사용자가 입력한 데이터 값에 접근할 수 있다.
    - 서버에 전달하는 파라미터(name은 key, value는 value)로 매핑하는 것

### HTTP request methods

- HTTP
    - HTML문서와 같은 리소스(데이터, 자원)들을 가져올 수 있도록 해주는 프로토콜(규칙, 규약)
- 웹에서 이루어지는 모든 데이터 교환의 기초
- HTTP는 주어진 리소스가 수행할 원하는 작업을 나타내는 request methods를 정의
- 자원에 대한 행위(수행하고자 하는 동작)를 정의
- 주어진 리소스(자원)에 수행하길 원하는 행동을 나타낸다
- HTTP Method 예시 : GET, ~~POST, PUT, DELETE(나중에)~~

### GET(대문자 사용 권장)

- 서버로부터 정보를 조회하는 데 사용한다. 즉, 서버에게 리소스를 요청하기 위해 사용
- 데이터를 가져올 때만 사용해야 한다.
- 데이터를 서버로 전송할 때 Query String Parameters를 통해 전송
    - 데이터는 URL에 포함되어 서버로 보내진다.

### Query String Parameters

- 사용자가 입력 데이터를 전달하는 방법 중 하나로, url주소에 데이터를 파라미터를 통해 넘기는 것
- 이러한 문자열은 앰퍼샌드(&)로 연결된 key=value쌍으로 구성되며 기본 URL과 물음표(?)로 구분 된다. ex) http://host:port/path?key=value&key=value ⇒ 물음표부터 시작
- Query String라고도 한다.
- 정해진 주소 이후에 물음표를 쓰는 것으로 Query String이 시작함을 알린다.
- key=value로 필요한 파라미터의 값을 적는다. =로 key와 value가 구분된다.
- 파라미터가 여러 개일 경우 &를 붙여 여러 개의 파라미터를 넘길 수 있다.

## Retrieving the data(Server)

### Retrieving the data

- 데이터 가져오기(검색하기)
- 서버는 클라이언트로 받은 key-value쌍의 목록과 같은 데이터를 받게 된다.
- 이러한 목록에 접근하는 방법은 사용하는 특정 프레임워크에 따라 다르다.
- catch

### 데이터 가져오기

- 모든 요청 데이터는 view함수의 첫 번째 인자 request에 들어있다.

### Request and Response objects

- 요청과 응답 객체 흐름
1. 페이지가 요청되면 Django는 요청에 대한 메타데이터를 포함하는 HttpRequest object를 생성
2. 그리고 해당하는 적절한 view함수를 로드하고 HttpRequest를 첫 번째 인자로 전달
3. 마지막으로 view함수는 HttpResponse object를 반환

## Django Model

- Model(이하 모델)의 핵심 개념과 ORM을 통한 데이터베이스 조작 이해
- Django는 웹 애플리케이션의 데이터를 구조화하고 조작하기 위한 추상적인 계층(모델)을 제공

## Database

- 체계화된 데이터의 모임
- 검색 및 구조화 같은 작업을 보다 쉽게 하기 위해 조직화된 데이터를 수집하는 저장 시스템

### Database 기본 구조

1. 스키마(Schema)
2. 테이블(Table)

### 스키마(Schema)

- 뼈대(Structure)
- 데이터베이스에서 자료의 구조, 표현 방법, 관계 등을 정의한 구조

### 테이블(Table)

- 필드와 레코드를 사용해 조직된 데이터 요소들의 집합
- 관계(Relation)라고도 부른다

### 필드(field)

- 속성 혹은 컬럼(column)
- 각 필드에는 고유한 데이터 형식이 지정된다. ex) INT, TEXT 등

### 레코드(record)

- 튜플 혹은 행(row)
- 테이블의 데이터는 레코드에 저장된다.

### PK(Primary Key)

- 기본 키
- 각 레코드의 고유한 값(식별자로 사용)
- 기술적으로 다른 항목과 절대로 중복될 수 없는 단일 값(unique)
- 데이터베이스 관리 및 테이블 간 관계 설정 시 주요하게 활용 된다.

### 쿼리(Query)

- 데이터를 조회하기 위한 명령어
- 조건에 맞는 데이터를 추출하거나 조작하는 명령어(주로 테이블형 자료구조에서)
- Query를 날린다 ⇒ 데이터베이스를 조작한다.

## Model

- Django는 Model을 통해 데이터에 접근하고 조작
- 사용하는 데이터들의 필수적인 필드들과 동작들을 포함
- 저장된 데이터베이스의 구조(layout)
- 일반적으로 각각의 모델은 하나의 데이터베이스 테이블에 매핑(mapping)
    - 모델 클래스 1개 == 데이터베이스 1개

### Model 작성하기

- 새 프로젝트(crud), 앱(articles) 작성 및 앱 등록
- [models.py](http://models.py) 작성
    - 모델 클래스를 작성하는 것은 데이터베이스 테이블의 스키마를 정의하는 것
    - 모델 클래스 == 테이블 스키마

<aside>
💡 id 컬럼은 테이블 생성 시 Django가 자동으로 생성한다.

</aside>

### Model 이해하기

- 각 모델은 django.models.Model 클래스의 서브 클래스
- 클래스 상속 기반 형태의 Django 프레임워크 개발⇒ 프레임워크에서는 잘 만들어진 도구를 가져다가 잘 쓰는 것
- models 모듈을 통해 어떠한 타입의 DB 필드(컬럼)을 정의할 것인지 정의
- 클래스 변수(속성)명 ⇒ DB 필드의 이름
- 클래스 변수 값 (models 모듈의 Field 클래스) ⇒ DB 필드의 데이터 타입

### Django Model Field

- Django는 모델 필드를 통해 테이블의 필드(컬럼)에 저장할 데이터 유형(INT, TEXT)을 정의
- 데이터 유형에 따라 다양한 모델 필드를 제공한다.
- DataField(), CharField(), IntegerField() 등

### 사용한 모델 필드 알아보기

- CharField(max_length=None, **options)
    - 길이의 제한이 있는 문자열을 넣을 때 사용
    - max_length
        - 필드의 최대 길이(문자)
        - CharField의 필수 인자
        - 데이터베이스와 Django의 유효성 검사에서 활용된다.
- TextField(**options)
    - 글자의 수가 많을 때 사용
    - max_length 옵션 작성 시 사용자 입력 단계에서는 반영되지만, 모델과 데이터베이스 단계에는 적용되지 않는다.(CharField 를 사용해야 한다.)
        - 실제로 저장될 때 길이에 대한 유효성을 검증하지 않는다.

### 데이터베이스 스키마

- 지금까지 작성한 models.py는 데이터베이스 스키마를 정의한 것

## Migrations

- Django가 모델에 생긴 변화(필드 추가, 수정 등)를 실제 DB에 반영하는 방법

### Migrations 관련 주요 명령어

1. makemigrations
2. migrate

### makemigrations `python [manage.py](http://manage.py) makemigrations`

- 모델의 변경사항에 대한 새로운 migration을 만들 때 사용
- 명령어 실행 후 migrations/0001_initial.py가 생성된 것을 확인
- 파이썬으로 작성된 설계도

### migrate `python [manage.py](http://manage.py) migrate`

- makemigrations로 만든 설계도를 실제 데이터베이스에 반영하는 과정(db.sqlite3파일에 반영)
- 결과적으로 모델의 변경사항과 데이터베이스를 동기화

### Migrations 기타 명령어

1. showmigrations `python [manage.py](http://manage.py) migrate`
    - migrations 파일들이 migrate됐는지 안됐는지 여부를 확인하는 용도 [X] 표시가 있으면 migrate가 완료됐음을 의미
2. sqlmigrate  `python [manage.py](http://manage.py) migrate`
    - 해당 migrations파일이 SQL문으로 어떻게 해석될 지 미리 확인 할 수 있음

### 반드시 기억해야 할 migration 3단계

1. models.py에서 변경사항이 발생하면
2. migration 생성 ⇒ makemigrations
3. DB 반영(모델과 DB의 동기화) ⇒ migrate

### 그런데 설계도는 어떻게, 누가 해석할까

- makemigrations로 인해 만들어진 설계도는 파이썬으로 작성되어 있다.
- 그런데 SQL만 알아 들을 수 있다는 DB가 어떻게 이 설계도를 이해하고 동기화를 이룰 수 있을까?
- 바로 이 과정에서 중간에 번역을 담당하는 것이 ORM

## ORM

- Object-Relational-Mapping
- 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 (Django ↔ DB) 데이터를 변환하는 프로그래밍 기술
- 객체 지향 프로그래밍에서 데이터베이스를 연동할 때, 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법
- Django는 내장 Django ORM을 사용
- 즉, SQL을 사용하지 않고 데이터베이스를 조작할 수 있게 만들어주는 매개체

### 장단점

- 장점
    - SQL을 잘 알지 못해도 객체지향 언어(Python)로 DB조작이 가능
    - 객체 지향적 접근으로 인한 높은 생산성
- 단점
    - ORM만으로 세밀한 데이터베이스 조작을 구현하기 어려운 경우가 있음

### 사용 이유

- 생산성 ⇒ 현 시대 개발에서 가장 중요한 키워드
- DB를 객체(object)로 조작하기  위해 ORM을 사용할 것

### Model 정리

- 웹 애플리케이션의 데이터를 구조화하고 조작하기 위한 도구

## QuerySet API

### Database API

- Django가 제공하는 ORM을 사용해 데이터베이스를 조작하는 방법
- Mode을 정의하면 데이터를 만들고 읽고 수정하고 지울 수 있는 API를 제공

### Database API 구문

Article.objects.all()

Model class.Manager.Queryset API

### objects manager

- Django 모델이 데이터베이스 쿼리 작업을 가능하게 하는 인터페이스
- Django는 기본적으로 모든 Django모델 클래스에 대해 objects라는 Manager 객체를 자동으로 추가함
- 이 Manager를 통해 특정 데이터를 조작할 수 있음
- DB를 Python class로 조작할 수 있도록 여러 메서드를 제공하는 manager

### Query

- 데이터베이스에 특정한 데이터를 보여 달라는 요청
- 쿼리문을 작성한다 ⇒ 원하는 데이터를 얻기 위해 데이터베이스에 요청을 보낼 코드를 작성한다.
- 이 때, 파이썬으로 작성한 코드가 ORM에 의해 SQL로 변환되어 데이터베이스에 전달되며, 데이터베이스의 응답 데이터를 ORM이 QuerySet이라는 자료 형태로 변환하여 우리에게 전달

### QuerySet

- 데이터베이스에게서 전달 받은 객체 목록(데이터 모음)
    - 순회가 가능한 데이터로써 1개 이상의 데이터를 불러와 사용할 수 있음
- Django ORM을 통해 만들어진 자료형이며, 필터를 걸거나 정렬 등을 수행할 수 있음
- objects manager를 사용하여 복수의 데이터를 가져오는 queryset method를 사용할 때 반환되는 객체
- 단, 데이터베이스가 단일한 객체를 반환할 때는 QuerySet이 아닌 모델(Class)의 인스턴스로 반횐됨

### Queryset API

- QuerySet과 상호작용하기 위해 사용하는 도구(메서드, 연산자 등)
- 데이터를 생성하고, 읽고, 수정하고, 삭제해보기(CRUD)

### CRUD

- Create / Read / Update / Delete
- 생성 / 조회 / 수정 / 삭제
- 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능 4가지를 묶어서 일컫는 말

## CREATE

### 데이터 객체를 만드는(생성하는) 3가지 방법

**첫 번째 방법**

1. article = Article()
    - 클래스를 통한 인스턴스 생성
2. article.title
    - 클래스 변수명과 같은 이름의 인스턴스 변수를 생성 후 값 할당
3. article.save()
    - 인스턴스로 save 메서드 호출 ⇒ 비로소 DB에 데이터가 저장된다. (레코드 생성)

**두 번째 방법**

- 인스턴스 생성 시 초기 값을 함께 작성하여 생성

**세 번째 방법**

- QuerySet API 중 create() 메서드 활용

### .save()

- Saving object
- 객체를 데이터베이스에 저장함
- 데이터 생성 시 save를 호출하기 전에는 객체의 id값은 None ⇒ id값은 Django가 아니라 데이터베이스에서 계산되기 때문
- 단순히 모델 클래스를 통해 인스턴스를 생성하는 것은 DB에 영향을 미치지 않기 때문에 반드시 save를 호출해야 테이블에 레코드가 생성됨

## READ

- QuerySet API method를 사용해 데이터를 다양하게 조회하기
- QuerySet API method는 크게 2가지로 분류됨
    1. Methods that ‘return new querysets’
    2. Methods that ‘do not return querysets’

### all()

- QuerySet return
- 전체 데이터 조회

### get()

- 단일 데이터 조회
- 객체를 찾을 수 없으면 DoesNotExist 예외를 발생시키고, 둘 이상의 객체를 찾으면 MultipleObjectReturned 예외를 발생시킴
- 위와 같은 특징을 가지고 있기 때문에 primary key와 같이 고유성(uniqueness)을 보장하는 조회에서 사용해야 함

### filter()

- 지정된 조회 매개 변수와 일치하는 객체를 포함하는 새 QuerySet을 반환
- 조회된 객체가 없거나 1개여도 QuerySet을 반환

### Field lookups

- 특정 레코드에 대한 조건을 설정하는 방법
- QuerySet 메서드 filter(), exclude() 및 get()에 대한 키워드 인자로 지정됨

## UPDATE

### Update 과정

1. 수정하고자 하는 article 인스턴스 객체를 조회 후 반환 값을 저장
2. article 인스턴스 객체의 인스턴스 변수 값을 새로운 값으로 할당
3. save() 인스턴스 메서드 호출

## DELETE

### Delete 과정

1. 삭제하고자 하는 article 인스턴스 객체를 조회 후 반환 값을 저장
2. delete() 인스턴스 메서드 호출

## Admin site

- Django의 가장 강력한 기능 중 하나인 automatic admin interface
- 관리자 페이지
    - 사용자가 아닌 서버의 관리자가 활용하기 위한 페이지
    - 모델 class를 admin.py에 등록하고 관리
    - 레코드 생성 여부 확인에 매우 유용하며 직접 레코드를 삽입할 수도 있음

### admin 계정 생성 `python [manage.py](http://manage.py) createsuperuser`

- username과 password를 입력해 관리자 계정을 생성
- email은 선택사항이기 때문에 입력하지 않고 enter를 입력하는 것이 가능하다. 비밀번호 생성 시 보안상 터미널에 입력되지 않으니 무시하고 입력한다.
- 서버에 접속 후 로그인 하면 계정만 만든 경우 Django 관리자 화면에서 모델 클래스는 보이지 않는다.

### admin에 모델 클래스 등록

- 모델의 record를 보기 위해서는 admin.py에 등록 필요

```python
from django.contrib import admin
from .models import Article

admin.site.register(Article)
```

## CRUD with view functions

- 이전에 익힌 QuerySet API를 통해 view함수에서 직접 CRUD구현하기

## READ 1(index page)

### 전체 게시글 조회

- index 페이지에서는 전체 게시글을 조회해서 출력한다.

## READ2(detail page)

- 개별 게시글 상세 페이지 제작
- 모든 게시글마다 뷰 함수와 템플릿 파일을 만들 수는 없음 ⇒ 글의 번호(pk)를 활용해서 뷰 함수와 템플릿 파일로 대응
- Variable Routing 활용하기!

### urls

- URL로 특정 게시글을 조회할 수 있는 번호를 받음

### views

- Article.objects.get(pk=pk)에서 오른쪽 pk는 variable routing을 통해 받은 pk, 왼쪽 pk는 DB에 저장된 레코드의 id컬럼

## CREATE

- CREATE 로직을 구현하기 위해서는 몇 개의 view함수가 필요할까?
    - 사용자의 입력을 받을 페이지를 렌더링 하는 함수 1개 ⇒ ‘new’ view function
    - 사용자가 입력한 데이터를 전송 받아 DB에 저장하는 함수 1개 ⇒ ‘create’ view function

### Create

- views.py에서 create함수 만들 때 데이터를 생성하는 방법 중 2번째 방법이 흔하게 사용된다.
    - create메서드를 사용하는게 더 간단해 보이지만 추후 데이터가 저장되기 전에 유효성 검사 과정을 거치게 될 예정이고 유효성 검사가 진행된 후에 save메서드가 호출되는 구조를 택하기 위해서이다.

### Django shortcut function - “redirect()”

- 인자에 작성된 곳으로 다시 요청을 보냄
- 사용 가능한 인자
1. view name (URL pattern name) `return redirect('articles:index')`
2. absolute or relative URL `return redirect('articles/')`

## HTTP Method

### 우리의 약속

- HTTP : 네트워크 상에서 데이터를 주고 받기 위한 약속
- HTTP Method : 데이터(리소스)에 어떤 요청(행동)을 원하는지를 나타낸 것

### GET(R) & POST(C, U, D)

- GET
    - 어떠한 데이터(리소스)를 조회하는 요청
    - GET방식으로 데이터를 전달하면 Query String 형식으로 보내진다.

### 현재 코드 재검토

- 현재(form에 GET method사용, view함수에 GET 사용)는 게시글이 작성될 때 /articles/create/?title=11&content=22와 같은 URL로 요청이 보내짐
- GET은 쿼리 스트링 파라미터로 데이터를 보내기 때문에 url을 통해 데이터를 보냄
- 하지만 현재 요청은 데이터를 조회하는 것이 아닌 작성을 원하는 요청 ⇒ POST!
- POST
- 어떠한 데이터(리소스)를 생성(변경)하는 요청
- POST방식으로 데이터를 전달하면 Query String이 아닌 Body에 담겨서 보내짐

### HTTP request method

- Get
    - 특정 리소스를 가져오도록 요청할 때 사용
    - 반드시 데이터를 가져올 때만 사용해야 함
    - DB에 변화를 주지 않음
    - CRUD에서 R역할을 담당
- POST(form에 POST method사용, view함수에 POST사용)
    - 서버로 데이터를 전송할 때 사용
    - 서버에 변경사항을 만듦
    - 리소스를 생성/변경하기 위해 데이터를 HTTP body에 담아 전송
    - GET의 쿼리 스트링 파라미터와 다르게 URL로 데이터를 보내지 않음
    - CRUD에서 C/U/D역할을 담당
    - 그냥 사용하면 CSRF Token이 없으므로 Forbidden에러 발생

### 403 Forbidden(HTTP Status Code;상태 코드)

- 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미
- 서버에 요청은 도달했으나 서버가 접근을 거부할 때 반환된다.
- 즉, 게시글을 작성할 권한이 없다 ⇒ Django입장에서는 ‘작성자가 누구인지 모르기 때문에 함부로 작성할 수 없다’라는 의미
- 모델(DB)을 조작하는 것은 단순 조회와 달리 최소한의 신원 확인이 필요하기 때문

### CSRF

- Cross-Site-Request-Forgery
- 사이트 간 요청 위조
- 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹 페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법

### CSRF 공격 방어

- Security Token 사용 방식(CSRF Token)
    - 사용자의 데이터에 임의의 난수 값(token)을 부여해 매 요청마다 해당 난수 값을 포함시켜 전송 시키도록 함
    - 이후 서버에서 요청을 받을 때마다 전달된 token값이 유효한지 검증
    - 일반적으로 데이터 변경이 가능한 POST, PATCH, DELETE Method 등에 적용
    - Django는 DTL에서 csrf_token 템플릿 태그를 제공

### csrf_token 템플릿 태그 `{% csrf_koten %}`

- 해당 태그가 없다면 Django 서버는 요청에 대해 403 forbidden으로 응답
- 템플릿에서 내부 URL로 향하는 Post form을 사용하는 경우에 사용
- 외부 URL로 향하는 POST form에 대해서는 CSRF토큰이 유출되어 취약성을 유발할 수 있기 때문에 사용해서는 안됨.
- csrf_token은 해당 POST요청이 내가 보낸 것 인지를 검증하는 것

## UPDATE

- 수정은 CREATE로직과 마찬가지로 2개의 view함수가 필요
    - 사용자의 입력을 받을 페이지를 렌더링 하는 함수 1개 ⇒ ‘edit’ view function
    - 사용자가 입력한 데이터를 전송 받아 DB에 저장하는 함수 1개 ⇒ ‘create’ view function

## Handling HTTP requests

- HTTP requests 처리에 따른 view 함수 구조 변화
- new-create, edit-update의 함수 역할을 잘 살펴보면 하나의 공통점과 하나의 차이점이 있음
- 공통점
    - new-create는 모두 CREATE 로직을 구현하기 위한 공통 목적
    - edit-update는 모두 UPDATE로직을 구현하기 위한 공통 목적
- 차이점
    - new와 edit는 GET요청에 대한 처리만을, create와 update는 POST요청에 대한 처리만을 진행
- 이 공통점과 차이점을 기반으로, 하나의 view함수에서 method에 따라 로직이 분리되도록 변경

### Create

- new와 create view함수를 합침
- 각각의 역할은 request.method값을 기준으로 나뉨
- 불필요해진 new의 view함수와 url path를 삭제
- new.html → create.html 이름변경 및 action 속성 값 수정
- index 페이지에 있던 new 관련 링크 수정

### Update

- edit과 update view함수를 합침
- new와 마찬가지로 불필요해진 edit의 view함수와 url path를 삭제
- edit.html → update.html 이름변경으로 인한 관련 정보 수정

### Delete

- POST요청에 대해서만 삭제가 가능하도록 수정

## Django Form

- 지금까지 HTML form, input태그를 통해서 사용자로부터 데이터를 받았음
- 현재 우리 Django 서버는 들어오는 요청을 모두 수용하고 있는데, 이러한 요청 중에는 비정상적인 혹은 악의적인 요청이 있다는 것을 생각해야 한다.
- 이처럼 사용자가 입력한 데이터가 우리가 원하는 데이터 형식이 맞는지에 대한 유효성 검증이 반드시 필요 ⇒ 유효성 검증은 많은 부가적인 것들을 고려해서 구현해야 하는데, 이는 개발 생산성을 늦출뿐더러 쉽지 않은 작업임
- Django form은 이 과정에서 과중한 작업과 반복 코드를 줄여줌으로써 훨씬 쉽게 유효성 검증을 진행할 수 있도록 만들어 줌

### Form에 대한 Django의 역할

- Form은 Django의 유효성 검사 도구 중 하나로 외부의 악의적 공격 및 데이터 손상에 대한 중요한 방어 수단
- Django는 Form과 관련한 유효성 검사를 단순화하고 자동화할 수 있는 기능을 제공하여, 개발자가 직접 작성하는 코드보다 더 안전하고 빠르게 수행하는 코드를 작성할 수 있다. ⇒ 개발자가 필요한 핵심 부분만 집중할 수 있도록 돕는 프레임워크의 특성

### Django는 Form에 관련된 작업의 세 부분을 처리

1. 렌더링을 위한 데이터 준비 및 재구성
2. 데이터에 대한 HTML forms 생성
3. 클라이언트로부터 받은 데이터 수신 및 처리

## The Django Form Class

- Form Class ⇒ Django form 관리 시스템의 핵심

### Form Class 선언

- Model Class 선언과 비슷하다. 비슷한 이름의 필드 타입을 많이 가지고 있다. (이름만 같을 뿐 같은 필드는 아님)
- Model과 마찬가지로 상속을 통해 선언(forms 라이브러리의 Form 클래스를 상속받음)
- 앱 폴더에 forms.py를 생성 후 ArticleForm Class선언

<aside>
💡 Form Class를 [forms.py](http://forms.py)에 작성하는 것은 규약이 아니다. 더 나은 유지보수의 관점 그리고 관행적으로 forms.py 파일에 작성하는 것을 권장

</aside>

### 업데이트 후 출력 확인

- view 함수에서 정의한 ArticleForm의 인스턴스(form)하나로 input과 label 태그가 모두 렌더링 되는 것을 개발자 도구에서 확인, 각 태그의 속성 값들 또한 자동으로 설정되어 있음

### Form rendering options

- <label>&<input>쌍에 대한 3가지 출력 옵션
1. **as_p() ⇒ 특별한 상황 아니면 사용**
    - 각 필드가 단락(p태그)으로 감싸져서 렌더링
2. as_ul()
    - 각 필드가 목록 항목(li태그)으로 감싸져서 렌더링
    - ul태그는 직접 작성해야 함
3. as_table()
    - 각 필드가 테이블(tr태그) 행으로 감싸져서 렌더링

### Django의 2가지 HTML input 요소 표현

1. Form fields
    - 입력에 대한 유효성 검사 로직을 처리
    - 템플릿에서 직접 사용됨
2. Widgets
    - 웹 페이지의 HTML input 요소 렌더링을 담당 ⇒ 단순히 input 요소의 보여지는 부분을 변경
    - Widgets은 반드시 form fields에 할당 됨

## Widgets

- Django의 HTML input element의 표현을 담당
- 단순히 HTML 렌더링을 처리하는 것이며 유효성 검증과 아무런 관계가 없음 ⇒ 웹 페이지에서 input element의 단순 raw한 렌더링만을 처리하는 것일 뿐

## Django ModelForm

### ModelForm Class

- Model을 통해 Form Class를 만들 수 있는 helper class
- ModelForm은 Form과 똑같은 방식으로 View함수에서 사용

### ModelForm 선언

- forms라이브러리에서 파생된 ModelForm 클래스를 상속받음
- 정의한 ModelForm 클래스 안에 Meta클래스를 선언
- 어떤 모델을 기반으로 form을 작성할 것인지에 대한 정보를 Meta 클래스에 지정

### ModelForm에서의 Meta Class

- ModelForm의 정보를 작성하는 곳
- ModelForm을 사용할 경우 참조할 모델이 있어야 하는데, Meta class의 model 속성이 이를 구성함 그리고 참조하는 모델에 정의된 필드 정보를 Form에 적용함
- fields속성에 `__all__` 를 사용하여 모델의 모든 필드를 포함할 수 있음
- 또는 `exclude`속성을 사용하여 모델에서 포함하지 않을 필드를 지정할 수 있음

## Model Form 구현하기

### Create

- 유효성 검사를 통과하면 데이터 저장 후 상세 페이지로 리다이렉트
- 통과하지 못하면 작성 페이지로 리다이렉트

### `is_valid()` method

- 유효성 검사를 실행하고, 데이터가 유효한지 여부를 boolean으로 반환
- 데이터 유효성 검사를 보장하기 위한 많은 테스트에 대해 Django는 `is_valid()`를 제공하여 개발자의 편의를 도움

### The `save()` method

- form 인스턴스에 바인딩된 데이터를 통해 데이터베이스 객체를 만들고 저장
- ModelForm의 하위 클래스는 키워드 인자 instance 여부를 통해 생성할 지, 수정할 지를 결정함
- 제공되지 않은 경우 `save()`는 지정된 모델의 새 인스턴스를 만듦(CREATE)
- 제공되면 `save()`는 해당 인스턴스를 수정(UPDATE)

### UPDATE

- ModelForm의 인자 instance는 수정 대상이 되는 개체(기존 객체)를 지정
1. [request.POST](http://request.POST) : 사용자가 form을 통해 전송한 데이터(새로운 데이터)
2. instance : 수정이 되는 대상

### Form과 ModelForm

- ModelForm이 Form보다 더 좋은 것이 아니라 각자 역할이 다른 것
- Form
    - 사용자의 입력을 필요로 하며 직접 입력 데이터가 DB저장에 사용되지 않거나 일부 데이터만 사용될 때(예 - 로그인, 사용자의 데이터를 받아 인증 과정에서만 사용 후 별도로 DB에 저장하지 않음)
- ModelForm
    - 사용자의 입력을 필요로 하며 입력을 받은 것을 그대로 DB필드에 맞춰 저장할 때
    - 데이터의 유효성 검사가 끝나면 데이터를 각각 어떤 레코드에 매핑해야 할지 이미 알고 있기 때문에 곧바로 save()호출이 가능

## Static files

### Static File

- 응답할 때 별도의 처리 없이 파일 내용을 그대로 보여주면 되는 파일 ⇒ 사용자의 요청에 따라 내용이 바뀌는 것이 아니라 요청한 것을 그대로 보여주는 파일
- 파일 자체가 고정되어 있고, 서비스 중에도 추가되거나 변경되지 않고 고정 되어 있다. 예) 일반적으로 이미지, 자바스크립트 또는 CSS와 같은 미리 준비된 추가 파일(움직이지 않는)을 제공
- Django에서는 이런 파일들을 static file이라 함 ⇒ Django는 staticfiles앱을 통해 정적 파일과 관련된 기능을 제공

### Media File

- 미디어 파일
- 사용자가 웹에서 업로드하는 정적 파일(user-uploaded)
- 유저가 업로드 한 모든 정적 파일

### 웹 서버와 정적 파일

- 웹 서버의 기본동작은 특정 위치(URL)에 있는 자원을 요청(HTTP request)받아서 응답(HTTP response)을 처리하고 제공(serving)하는 것
- 이는 ‘자원과 자원에 접근 가능한 주소가 있다.’라는 의미. 예) 사진 파일은 자원이고 해당 사진 파일을 얻기 위한 경로인 웹 주소(URL)가 존재함
- 즉, 웹 서버는 요청 받은 URL로 서버에 존재하는 정적 자원(static resource)을 제공함

## Static files 구성하기

### Django에서 정적파일을 구성하고 사용하기 위한 몇가지 단계

1. INSTALLED_APPS에서 django.contrib.staticfiles가 포함되어 있는지 확인하기
2. settings.py에서 STATIC_URL을 정의하기
3. 앱의 static폴더에 정적 파일을 위치하기
4. 템플릿에서 static템플릿 태그를 사용하여 지정된 경로에 있는 정적 파일의 URL 만들기

### DJango template tag

- load tag  `{% load %}`
    - 특정 라이브러리, 패키지에 등록된 모든 템플릿 태그와 필터를 로드
- static tag `{% static '' %}`
    - STATIC_ROOT에 저장된 정적 파일에 연결

### Static files 관련 Settings

1. ~~STATIC_ROOT(배포)~~
    - Default: None
    - Django 프로젝트에서 사용하는 모든 정적 파일을 한 곳에 모아 넣는 경로
    - collectstatic이 배포를 위해 정적 파일을 수집하는 디렉토리의 절대 경로
    - 개발 과정에서 settings.py의 DEBUG 값이 True로 설정되어 있으면 해당 값은 작용되지 않음
    - 실 서비스 환경(배포 환경)에서 Django의 모든 정적 파일을 다른 웹 서버가 직접 제공하기 위해 사용
    - 배포 환경에서는 Django를 직접 실행하는 것이 아니라, 다른 서버에 의해 실행되기 때문에 실행하는 다른 서버는 Django에 내장되어 있는 정적 파일들을 인식하지 못함(내장되어 있는 정적 파일들을 밖으로 꺼내는 이유)
2. ~~STATICFILES_DIRS~~
    - Default: [](Empty list)
    - app/static/ 디렉토리 경로를 사용하는 것(기본 경로) 외에 추가적인 정적 파일 경로 목록을 정의하는 리스트
    - 추가 파일 디렉토리에 대한 전체 경로를 포함하는 문자열 목록으로 작성되어야 함
3. **STATIC_URL : URL경로 지정**
    - Default: None
    - STATIC_ROOT에 있는 정적 파일을 참조할 때 사용할 URL
    - 개발 단계에서는 실제 정적 파일들이 저장되어 있는 app/static/ 경로(기본 경로) 및 STATICFILES_DIRS에 정의된 추가 경로들을 탐색
    - 실제 파일이나 디렉토리가 아니며, URL로만 존재
    - 비어 있지 않은 값으로 설정 한다면 반드시 ‘/’로 끝나야 함
    
    <aside>
    💡 STATIC_URL은 ‘STATIC_URL + static file 경로’로 설정됨
    ⇒ http://127.0.0.1:8000/static/articles/sample_img.png
    
    </aside>
    

## Media Files

### `ImageField()`

- 이미지 업로드에 사용하는 모델 필드
- FileField를 상속받는 서브 클래스이기 때문에 FileField의 모든 속성 및 메서드를 사용 가능
- 더해서 사용자에 의해 업로드 된 객체가 유효한 이미지인지 검사
- ImageField 인스턴스는 최대 길이가 100자인 문자열로 DB에 생성되며, max_length인자를 사용하여 최대 길이를 변경할 수 있음

### `FileField()`

- `FileField(upload_to=’’, storage=None, max_length=100, **options)`
- 파일 업로드에 사용하는 모델 필드
- 2개의 선택 인자를 가지고 있음
    1. upload_to
    2. ~~storage~~

### FileField/ImageField를 사용하기 위한 단계

1. settings.py에 MEDIA_ROOT, MEDIA_URL 설정
2. upload_to 속성을 정의하여 업로드 된 파일에 사용할 MEDIA_ROOT의 하위 경로를 지정(선택사항)

### MEDIA_ROOT

- Default: ‘’(Empty string)
- 사용자가 업로드 한 파일(미디어 파일)들을 보관할 디렉토리의 절대 경로
- Django는 성능을 위해 업로드 파일은 데이터베이스에 저장하지 않음 ⇒ 데이터베이스에 저장되는 것은 **파일경로**
- MEDIA_ROOT는 STATIC_ROOT와 반드시 다른 경로로 지정해야 함

### MEDIA_URL

- Default: ‘’(Empty string)
- MEDIA_ROOT에서 제공되는 미디어 파일을 처리하는 URL
- 업로드 된 파일의 주소(URL)를 만들어 주는 역할 ⇒ 웹 서버 사용자가 사용하는 public URL
- 비어 있지 않은 값으로 설정 한다면 반드시 ‘/’로 끝나야 함
- MEDIA_URL은 STATIC_URL과 반드시 다른 경로로 지정해야 함

### 개발 단계에서 사용자가 업로드한 미디어 파일 제공하기

```python
# urls.py
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('articles/', include('articles.urls')),
    ...
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

- 사용자로부터 업로드 된 파일이 프로젝트에 업로드 되고 나서, 실제로 사용자에게 제공하기 위해서는 업로드 된 파일의 URL이 필요함
    - 업로드 된 파일의 URL == settings.MEDIA_URL
    - 위 URL을 통해 참조하는 파일의 실제 위치 == settings.MEDIA_ROOT

## Media File 사용하기

## CREATE

### ImageField 작성

- 기존 컬럼 사이에 작성해도 실제 테이블에 추가될 때는 가장 우측(뒤)에 추가됨

### Model field option

- blank
    - Default : False
        - True인 경우 필드를 비워 둘 수 있음 ⇒ 이럴 경우 DB에는 ‘’(빈 문자열)이 저장됨
    - 유효성 검사에서 사용 됨(is_valid)
        - validation-related
        - 필드에 blank=True가 있으면 form유효성 검사에서 빈 값을 입력할 수 있음
- null
    - Default : False
    - True인 경우 Django는 빈 값을 DB에 NULL로 저장함
        - Database-related
    - CharField, TextField와 같은 문자열 기반 필드에는 null 옵션 사용을 피해야 함
        - 문자열 기반 필드에 null=True로 설정 시 데이터 없음에 대한 표현에 빈 문자열과 NULL 2가지 모두 가능하게 됨
        - 데이터 없음에 대한 표현에 두 개의 가능한 값을 갖는 것은 좋지 않음
        - Django는 문자열 기반 필드에서 NULL이 아닌 빈 문자열을 사용하는 것이 규칙

### Migrations

- ImageField를 사용하려면 반드시 Pillow 라이브러리가 필요 ⇒ pillow 설치 없이는 makemigrations 실행 불가

```bash
pip install pillow
python manage.py makemigrations
python manage.py migrate
pip freeze > requirements.txt
```

### ArticleForm에서 image필드 출력 확인

- 파일 또는 이미지 업로드 시에는 form 태그에 `enctype=”multipart/form-data”`

### request.FILES

- 파일 및 이미지는 request의 POST 속성 값으로 넘어가지 않고 FILES 속성 값에 담겨 넘어감 ⇒ Class의 생성자 함수에 두번째에 위치하므로 항상 두번째 값으로 넣어줘어야 함

### 이미지 첨부하기

- 이미지를 첨부하지 않으면 blank=True 속성으로 인해 빈 문자열이 저장되고, 이미지를 첨부하면 MEDIA_ROOT 경로에 이미지가 업로드 됨

<aside>
💡 파일 자체가 아닌 **경로**가 저장된다는 것을 잊지 말것

</aside>

## READ

### 업로드 이미지 출력하기

- 이미지를 업로드하지 않은 게시물은 detail 템플릿을 출력할 수 없는 문제 해결하기
- 이미지 데이터가 있는 경우만 이미지 출력할 수 있도록 if 템플릿 태그 사용하기

## 인증과 권한

- Django authentication system(인증 시스템)은 인증(Authentication)과  권한(Authorization) 부여를 함께 제공(처리)하며, 이러한 기능을 일반적으로 인증 시스템이라고 함
- 필수 구성은 settings.py에 이미 포함되어 있으며 INSTALLED_APPS에서 확인 가능
    - `django.contrib.auth`
- Authentication(인증)
    - 신원 확인
    - 사용자가 자신이 누구인지 확인하는 것
- Authorization(권한, 허가)
    - 권한 부여
    - 인증된 사용자가 수행할 수 있는 작업을 결정

### 사전 설정

- 두 번째 app accounts 생성 및 등록(accounts로 만들기!)

## Custom User model

- Custom User Model로 대체하기
- 개발자들이 작성하는 일부 프로젝트에서는 django에서 제공하는 built-in User model의 기본 인증 요구사항이 적절하지 않을 수 있음. 예) 회원가입 시 username대신 email을 식별 값으로 사용하는 것이 더 적합할 경우, DJango의 User Model은 기본적으로 username을 식별 값으로 사용하기 때문에 적합하지 않음
- Django는 현재 프로젝트에서 사용할 User Model을 결정하는 AUTH_USER_MODEL 설정 값으로 Default User Model을 재정의(override)할 수 있도록 함

### AUTH_USER_MODEL

- 프로젝트에서 User를 나타낼 때 사용하는 모델
- 프로젝트가 진행되는 동안 (모델을 만들고 마이그레이션 한 후) 변경할 수 없음
- 프로젝트 시작 시 설정하기 위한 것이며, 참조하는 모델은 첫 번째 마이그레이션에서 사용할 수 있어야 함. 즉, 첫 번째 마이그레이션 전에 확정 지어야 함
- 기본 값으로 `AUTH_USER_MODEL = 'auth.User'`

### 대체하기

- AbstractUser를 상속받는 커스텀 User 클래스 작성
- 기존 User 클래스도 AbstractUser를 상속받기 때문에 커스텀 User 클래스도 완전히 같은 모습을 가지게 됨
- Django 프로젝트에서 User를 나타내는데 사용하는 모델을 방금 생성한 커스텀 User모델로 지정
    - `AUTH_USER_MODEL = 'accounts.User'`
- admin.py에 커스텀 User모델을 등록 ⇒ 기본 User 모델이 아니기 때문에 등록하지 않으면 admin site에 출력되지 않음

<aside>
💡 [주의] 프로젝트 중간에 AUTH_USER_MODEL 변경하는 것은 모델 관계에 영향을 미치기 때문에 훨씬 더 어려운 작업이 필요하고 여러 에러가 일어날 가능성이 높다. 결론은 중간 변경은 권장하지 않고 프로젝트 처음에 진행해야 한다.

</aside>

### 데이터베이스 초기화(중요)

1. migrations 파일 삭제
    - migrations 폴더 및 _ _init _ _.py는 삭제하지 않음
    - 번호가 붙은 파일과 캐시만 삭제
2. db.sqlite3 삭제
3. migrations 진행
    - makemigrations
    - migrate
- DB 확인 시 이제 auth_user 테이블이 아니라 accounts_user 테이블을 사용하게 됨

### 반드시 User 모델을 대체해야 할까?

- Django는 새 프로젝트를 시작하는 경우 비록 기본 User 모델이 충분하더라도 커스텀 User 모델을 설정하는 것을 **강력하게 권장(highly recommended)**
- 커스텀 User 모델은 기본 User 모델과 동일하게 작동 하면서도 필요한 경우 나중에 맞춤 설정할 수 있기 때문이다. 단, User 모델 대체 작업은 프로젝트의 모든 migrations 혹은 첫 migrate를 실행하기 전에 이 작업을 마쳐야 함.

## HTTP(Hyper Text Transfer Protocol)

- HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜(규칙, 규약)
- 웹(WWW)에서 이루어지는 모든 데이터 교환의 기초
- 클라이언트-서버 프로토콜이라고도 부름

### 요청과 응답

- 요청(requests) : 클라이언트(브라우저)에 의해 전송되는 메시지
- 응답(response) : 서버에서 응답으로 전송되는 메시지

### HTTP 특징

1. 비 연결 지향(connectionless)
    - 서버는 요청에 대한 응답을 보낸 후 연결을 끊음
2. 무상태(stateless) ⇒ 기억 못함
    - 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않음
    - 클라이언트와 서버가 주고받는 메시지들은 서로 완전히 독립적

### 어떻게 로그인 상태를 유지할까?

- 로그인을 하고 웹 사이트를 사용할 때 페이지를 이동해도 로그인 ‘상태’가 유지됨
- 서버와 클라이언트 간 지속적인 상태 유지를 위해 **‘쿠키와 세션’**이 존재

## 쿠키(Cookie)

- HTTP  쿠키는 상태가 있는 세션을 만들도록 해 줌

### 개념

- 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다.
- 사용자가 웹사이트를 방문할 경우 해당 웹사이트의 서버를 통해 사용자의 컴퓨터에 설치되는 작은 기록 정보 파일
    1. 브라우저(클라이언트)는 쿠키를 로컬에 KEY-VALUE의 데이터 형식으로 저장
    2. 이렇게 쿠키를 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 쿠키를 함께 전송
- 쿠키는 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용됨
    - 이를 이용해 사용자의 로그인 상태를 유지할 수 있음
    - 상태가 없는(stateless) HTTP 프로토콜에서 상태 정보를 기억시켜 주기 때문
- 즉, 웹 페이지에 접속하면 웹 페이지를 응답한 서버로부터 쿠키를 받아 브라우저에 저장하고, 클라이언트가 같은 서버에 재요청 시마다 요청과 함께 저장해 두었던 쿠키도 함께 전송

### 쿠키 사용 목적

1. 세션 관리(Session management) : 로그인, 아이디 자동완선, 공지 하루 안 보기, 팝업 체크, 장바구니 등의 정보 관리
2. 개인화(Personalization) : 사용자 선호, 테마 등의 설정
3. 트래킹(Tracking) : 사용자 행동을 기록 및 분석

### 세션(Session)

- 사이트와 특정 브라우저 사이의 state(상태)를 유지시키는 것
- 클라이언트가 서버에 접속하면 서버가 특정 session id를 발급하고, 클라이언트가 서버에 접속하면 서버가 특정 session id를 발급하고, 클라이언트는 session id를 쿠키에 저장
    - 클라이언트가 다시 동일한 서버에 접속하며 요청과 함께 쿠키(session id가 저장된)를 서버에 전달
    - 쿠키는 요청 때마다 서버에 함께 전송되므로 서버에서 session id를 확인해 알맞은 로직을 처리
- session id는 세션을 구별하기 위해 필요하며, 쿠키에는 session id만 저장

### 쿠키 Lifetime(수명)

1. Session cookie
    - 현재 세션(current session)이 종료되면 삭제됨
    - 브라우저 종료와 함께 세션이 삭제됨
2. Persistent cookies
    - Expires 속성에 지정된 날짜 혹은 Max-Age 속성에 지정된 기간이 지나면 삭제됨

### Session in Django

- Django는 database-backed sessions 저장 방식을 기본 값으로 사용

## Authentication in Web requests

## Login

- 로그인은 Session을 Create하는 과정

### AuthenticationForm

- 로그인을 위한 built-in form
    - 로그인 하고자 하는 사용자 정보를 입력 받음
    - 기본적으로 username과 password를 받아 데이터가 유효한지 검증
- request를 첫 번째 인자로 취함

### `login()`

- `login(request, user, backend=None)`
- 인증된 사용자를 로그인 시키는 로직으로 view 함수에서 사용됨
- 현재 세션에 연결하려는 인증된 사용자가 있는 경우 사용
- HttpRequest 객체와 User 객체가 필요

### `get_user()`

- AuthenticationForm의 인스턴스 메서드
- 유효성 검사를 통과했을 경우 로그인 한 사용자 객체를 반환

## Authentication with User

- 템플릿에서 인증 관련 데이터를 출력하는 방법

### 현재 로그인 되어있는 유저 정보 출력하기

- base 템플릿에서 context 데이터 없이 user 변수를 사용할 수 있는데, settings.py의 context processors 설정 값 때문에 기본적으로 사용할 수 있는 템플릿 변수들이 있다.

### context processors

- 템플릿이 렌더링될 때 호출 가능한 컨텍스트 데이터 목록
- 작성된 컨텍스트 데이터는 기본적으로 템플릿에서 사용 가능한 변수로 포함됨
- 즉, django에서 자주 사용하는 데이터 목록을 미리 템플릿에 로드해 둔 것

### django.contrib.auth.context_processors.auth

- 현재 로그인한 사용자를 나타내는 User 클래스의 인스턴스가 템플릿 변수 {{user}}에 저장됨
    - 클라이언트가 로그인하지 않은 경우 AnonymousUser 클래스의 인스턴스로 생성

## Logout

- 로그아웃은 Session을 Delete하는 과정(클라이언트와 DB에서)

### `logout()`

- `logout(request)`
- HttpRequest 객체를 인자로 받고 반환 값이 없음
- 사용자가 로그인하지 않은 경우 오류를 발생시키지 않음
- 다음 2가지 일을 처리한다
    1. 현재 요청에 대한 session data를 DB에서 삭제
    2. 클라이언트의 쿠키에서도 session id를 삭제
    - 이는 다른 사람이 동일한 웹 브라우저를 사용하여 로그인하고, 이전 사용자의 세션 데이터에 액세스하는 것을 방지하기 위함

## 인증과 권한

- HTTP의 특징 ⇒ 1. 비 연결 지향 2. 무상태
- 서버-클라이언트간 ‘상태’를 유지하기 위한 기술 ⇒ 1. 쿠키 2. 세션
- 로그인 ⇒ 사용자에 대한 세션을 생성하는 것
- 로그아웃 ⇒ 세션을 클라이언트와 서버에서 삭제하는 것

## Authentication with User

- User object와 User CRUD에 대한 이해 : 회원 가입, 회원 탈퇴, 회원정보 수정, 비밀번호 변경

## 회원 가입

- 회원가입은 User를 Create하는 것이며 UserCreationForm built-in form을 사용

### UserCreationForm

- 주어진 username과 password로 권한이 없는 새 user를 생성하는 ModelForm
- 3개의 필드를 가짐
1. username (from the user model)
2. password1
3. Password2

## Custom User & Built-in auth forms

- Custom user와 기존 Built-in auth forms간의 관계
- Custom user로 인한 Built-in auth forms 변경

### AbstractBaseUser의 모든 subclass와 호환되는 forms

- 아래 Form 클래스는 User 모델을 대체하더라도 커스텀하지 않아도 사용가능
    1. AuthenticationForm
    2. SetPasswordForm
    3. PasswordChangeForm
    4. AdminPasswordChangeForm
- 기존 User 모델을 참조하는 Form이 아니기 때문

### 커스텀 유저 모델을 사용하려면 다시 작성하거나 확장해야 하는 forms

1. UserCreationForm ⇒ CustomUserCreationForm(회원가입)
2. UserChangeForm ⇒ CustomUserChangeForm(회원정보수정)
- 두 form 모두 class Meta: model = User가 등록된 form이기 때문에 반드시 커스텀(확장)해야 함

### `get_user_model()`

- 현재 프로젝트에서 활성화된 사용자 모델(active user model)을 반환
- 직접 참조하지 않는 이유 : 예를 들어 기존 User 모델이 아닌 User 모델을 커스텀한 상황에서는 커스텀 User 모델을 자동으로 반환해주기 때문
- Django는 User 클래스를 직접 참조하는 대신 get_user_model()을 사용해 참조해야 한다고 강조하고 있음

### [참고] UserCreationForm의 save 메서드 ⇒ user를 반환한다.

## 회원 탈퇴

- DB에서 유저를 Delete하는 것과 같음

### [참고] 탈퇴하면서 해당 유저의 세션 정보도 함께 지우고 싶을 경우

- 탈퇴 후 로그아웃 ⇒ 순서가 바뀌면 안된다.
- 먼저 로그아웃 해버리면 해당 요청 객체 정보가 없어지기 때문에 탈퇴에 필요한 정보 또한 없어지기 때문

## 회원정보 수정

- 회원정보 수정은 User를 Update하는 것이며 UserChangeForm built-in form을 사용

### UserChangeForm

- 사용자의 정보 및 권한을 변경하기 위해 admin 인터페이스에서 사용되는 ModelForm
- UserChangeForm 또한 ModelForm이기 때문에 instance인자로 기존 user 데이터 정보를 받는 구조 또한 동일함

### UserChangeForm 사용 시 문제점

- 일반 사용자가 접근해서는 안 될 정보들(fields)까지 모두 수정이 가능해짐 ⇒ admin 인터페이스에서 사용되는 ModelForm이기 때문
- 따라서 UserChangeForm을 상속받아 작성해 두었던 서브 클래스 CustomUserChangeForm에서 접근 가능한 필드를 조정해야 함

### User model 상속 구조 살펴보기

1. UserChangeForm 클래스 구조 확인
    - Meta 클래스를 보면 User라는 model을 참조하는 ModelForm이라는 것을 확인할 수 있음
2. User 클래스 구조 확인
    - 실제로 User클래스는 Meta 클래스를 제외한 코드가 없고 AbstractUser 클래스를 상속 받고 있음
3. AbstractUser 클래스 구조 확인
    - 클래스 변수명들을 확인해보면 회원수정 페이지에서 봤던 필드들과 일치한다는 것을 확인할 수 있음
4. 마지막으로 공식문서의 User 모델 Fields 확인

### CustomUserChangeForm fields 재정의

- 수정하고자 하는 필드 작성 후 출력 변화 확인

### PasswordChangeForm

- 사용자가 비밀번호를 변경할 수 있도록 하는 Form
- 이전 비밀번호를 입력하여 비밀번호를 변경할 수 있도록 함
- 이전 비밀번호를 입력하지 않고 비밀번호를 설정할 수 있는 SetPasswordForm을 상속받는 서브 클래스
- 회원정보 수정 페이지에서 비밀번호 변경 form주소를 확인해보기

### [참고] SetPasswordForm 살펴보기

- PasswordChangeForm은 SetPasswordForm의 하위 클래스이기 때문에 SetPasswordForm을 확인

### 암호 변경 시 세션 무효화 방지하기

- 비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어버려 로그인 상태가 유지되지 못함
- 비밀번호는 잘 변경되었으나 비밀번호가 변경되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문

### update_session_auth_hash()

- update_session_auth_hash(request, user)
- 현재 요청(current request)과 새 session data가 파생될 업데이트된 사용자 객체를 가져오고, session data를 적절하게 업데이트해줌
- 암호가 변경되어도 로그아웃 되지 않도록 새로운 password의 session  data로 session을 업데이트

## View decorators

- View decorators를 사용해 view 함수를 단단하게 만들기

### Decorator

- 기존에 작성된 함수에 기능을 추가하고 싶을 때, 해당 함수를 수정하지 않고 기능을 추가해주는 함수
- Django는 다양한 HTTP 기능을 지원하기 위해 view함수에 적용할 수 있는 여러 데코레이터를 제공

## Allowed HTTP methods

- django.views.decorators.http의 데코레이터를 사용하여 요청 메서드를 기반으로 접근을 제한할 수 있음
- 일치하지 않는 메서드 요청이라면 405 Method Not Allowed를 반환
- 메서드 목록
    1. `require_http_methods()`
    2. `require_POST()`
    3. `require_safe()`

### [참고] 405 Method Not Allowed

- 요청 방법이 서버에게 전달되었으나 사용 불가능한 상태

### `require_http_methods()`

- View함수가 특정한 요청 method만 허용하도록 하는 데코레이터

### `require_POST()`

- View함수가 POST요청 method만 허용하도록 하는 데코레이터
- url로 delete 시도하면 405 http status code

### `require_safe()`

- require_GET이 있지만 Django에서는 require_safe를 사용하는 것을 권장

## Limiting access to logged-in users

- 로그인 사용자에 대한 접근 제한하기 ⇒ `is_authenticated` attribute

### `is_authenticated`

- User model의 속성(attributes) 중 하나
- 사용자가 인증 되었는지 여부를 알 수 있는 방법
- 모든 User 인스턴스에 대해 항상 True인 읽기 전용 속성 ↔ AnonymousUser에 대해서는 항상 False
- 일반적으로 `request.user`에서 이 속성을 사용(`request.user.is_authenticated`  ⇒ `user.is_authenticated` 로 사용 가능)

<aside>
💡 권한(permission)과는 관련이 없으며, 사용자가 활성화 상태(active)이거나 유효한 세션(valid session)을 가지고 있는지도 확인하지 않음

</aside>

### is_authenticated 적용하기

- 로그인과 비로그인 상태에서 출력되는 링크를 다르게 설정하기(if 템플릿 태그 사용)
- 인증된 사용자만 게시글 작성 링크를 볼 수 있도록 처리하기
- 인증된 사용자라면 로그인 로직을 수행할 수 없도록 처리(데코레이터 가능)

## HTTP(HyperText Transfer Protocol)

- HTML 문서와 같은 리소스(resource, 자원)들을 가져올 수 있도록 하는 프로토콜(규칙, 약속)
- 웹 상에서 컨텐츠를 전송하기 위한 약속
- 웹에서 이루어지는 모든 데이터 교환의 기초가 됨
- 클라이언트-서버 프로토콜이라고도 부름
- 클라이언트와 서버는 다음과 같은 개별적인 메시지 교환에 의해 통신
- 요청(request) : 클라이언트에 의해 전송되는 메시지 ↔ 응답(response) : 서버에서 응답으로 전송되는 메시지

### HTTP 특징

- **Stateless(무상태)**
- 동일한 연결(connection)에서 연속적으로 수행되는 두 요청 사이에 링크가 없음
- 즉, 응답을 마치고 연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않음

### HTTP Request Methods

- 리소스에 대한 행위(수행하고자 하는 동작)를 정의
- 즉, 리소스에 대해 수행할  원하는 작업을 나타내는 메서드 모음을 정의
- HTTP verbs라고도 함
- GET, POST, PUT, DELETE, PATCH 등
- HTTP 요청의 대상을 리소스(resource)라고 함

### 대표 HTTP Request Methods

1. GET : 서버에 리소스의 표현을 요청, GET을 사용하는 요청은 데이터만 검색해야 함
2. POST : 데이터를 지정된 리소스에 제출, 서버의 상태를 변경
3. PUT : 요청한 주소의 리소스를 수정
4. DELETE : 지정된 리소스를 삭제

### HTTP response status codes

- 특정 HTTP 요청이 성공적으로 완료 되었는지 여부를 나타냄
1. Informational responses(100-199)
2. Successful responses(200-299)
3. Redirection messages(300-399)
4. Client error responses(400-499)
5. Server error responses(500-599)

## Identifying resources on the Web

### 웹에서의 리소스 식별

- HTTP 요청의 대상을 리소스(resource, 자원)라고 함
- 리소스는 문서, 사진 또는 기타 어떤 것이든 될 수 있음
- 각 리소스는 식별을 위해 **URI**로 식별됨

## URI

- Uniform Resource Identifier (통합 자원 식별자)
- 인터넷에서 리소스를 식별하는 문자열
- 가장 일반적인 URI는 웹 주소로 알려진 **URL**
- 특정 이름공간에서 이름으로 리소스를 식별하는 URI는 **URN**(예 : ISBN) → 리소스를 찾아가는 경로를 제공하지 않음

### URL

- Uniform Resource Locator(통합 자원 위치)
- 웹에서 주어진 리소스의 주소
- 네트워크 상에 리소스가 어디 있는지(주소)를 알려주기 위한 약속. 이러한 리소스는 HTML, CSS, 이미지 등이 될 수 있음

http://www.example.com:80/path/to/mylife.html?key1=value1&key2=value2#Somewhere

Scheme  Domain Name  Port   Path to the file       Parameters                         Anchor

### URL 구조

- **Scheme(or protocol)**
    - 브라우저가 리소스를 요청하는 데 사용해야 하는 프로토콜
    - URL의 첫 부분은 브라우저가 어떤 규약을 사용하는지를 나타냄
    - 기본적으로 웹은 HTTP(S)를 요구하며 메일을 열기 위한 **mailto:**, 파일을 전송하기 위한 **ftp:** 등 다른 프로토콜도 존재
- Authority
    - Scheme 다음은 문자 패턴 ://으로 구분된 Authority(권한)이 작성됨
    - Authority는 domain과 port를 모두 포함하며 둘은 :(콜론)으로 구분됨
    1. Domain Name
        - 요청 중인 웹 서버를 나타냄
        - 어떤 웹 서버가 요구되는 지를 가리키며 직접 IP주소를 사용하는 것도 가능하지만, 사람이 외우기 어렵기 때문에 주로 Domain Name으로 사용
    2. Port
        - 웹 서버의 리소스에 접근하는데 사용되는 기술적인 문(Gate)
        - HTTP 프로토콜의 표준 포트는 다음과 같고 생략이 가능(나머지는 생략 불가능)
            - HTTP - 80
            - HTTPS - 443
        - Django의 경우 8000(80 + 00)이 기본 포트로 설정되어 있음
- Path
    - 웹 서버의 리소스 경로
    - 초기에는 실제 파일이 위치한 물리적 위치를 나타냈지만, 오늘날은 실제 위치가 아닌 추상화된 형태의 구조를 표현
    - 예를 들어 /articles/create/가 실제 articles 폴더 안에 create 폴더 안을 나타내는 것은 아님
- Parameters
    - 웹 서버에 제공하는 추가적인 데이터
    - 파라미터는 **&**기호로 구분되는 key-value 쌍 목록
    - 서버는 리소스를 응답하기 전에 이러한 파라미터를 사용하여 추가 작업을 수행할 수 있음
- Anchor
    - 리소스의 다른 부분에 대한 앵커
    - 리소스 내부 일종의 북마크를 나타내며 브라우저에 해당 북마크 지점에 있는 콘텐츠를 표시
        - 예를 들어 HTML 문서에서 브라우저는 앵커가 정의한 지점으로 스크롤 함
    - fragment identifier(부분 식별자)라고 부르는 **#**이후 부분은 서버에 전송되지 않음

### URN

- Uniform Resource Name(통합 자원 이름)
- URL과 달리 자원의 위치에 영향을 받지 않는 유일한 이름 역할을 함(독립적 이름)
- URL의 단점을 극복하기 위해 등장했으며 자원이 어디에 위치한지 여부와 관계없이 이름만으로 자원을 식별
- 하지만 이름만으로 실제 리소스를 찾는 방법은 보편화되어 있지 않아 현재는 URL을 대부분 사용

### 웹에서의 리소스 식별 정리

- 자원의 식별자(URI)
    - 자원의 위치로 자원을 식별(URL)
    - 고유한 이름으로 자원을 식별(URN)

## 클라이언트와 서버

### 클라이언트-서버 구조

- 오늘날 우리가 사용하는 대부분의 웹 서비스는 클라이언트-서버 구조를 기반으로 동작
- 클라이언트와 서버 역시 하나의 컴퓨터
- 클라이언트는 서버에 어떤 자원(resource)을 달라고 요청(requests)을 보내고 서버는 클라이언트에 응답(response)을 보내 자원을 제공한다.
- 클라이언트
    - 웹 사용자의 인터넷에 연결된 장치(예: wi-fi에 연결된 컴퓨터나 모바일)
    - Chrome 또는 Firefox와 같은 웹 브라우저
    - 서비스를 요청하는 주체
- 서버
    - 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터
    - 클라이언트가  웹 페이지에 접근하려고 할 때 서버에서 클라이언트 컴퓨터로 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시됨
    - 요청에 대해 서비스를 응답하는 주체

## REST API

### API(Application Programming Interface)

- 애플리케이션과 프로그래밍으로 소통하는 방법
    - 개발자가 복잡한 기능을 보다 쉽게 만들 수 있도록 프로그래밍 언어로 제공되는 구성
- API를 제공하는 애플리케이션과 다른 소프트웨어 및 하드웨어 등의 것들 사이의 간단한 계약(인터페이스)이라고 볼 수 있음
- API는 복잡한 코드를 추상화하여 대신 사용할 수 있는 몇 가지 더 쉬운 구문을 제공

### Web API

- 웹 서버 또는 웹 브라우저를 위한 API
- 현재 웹 개발은 모든 것을 하나부터 열까지 직접 개발하기보다 여러 open API를 활용하는 추세
- 대표적인 Third Pary Open API 서비스 목록
    - Youtube API
    - Naver Papago API
- API는 다양한 타입의 데이터를 응답
    - **HTML, XML, JSON** 등

### REST(Representational State Transfer)

- API Server를 개발하기 위한 일종의 소프트웨어 설계 방법론
    - 2000년 로이 필딩의 박사학위 논문에서 처음으로 소개된 후 네트워킹 문화에 널리 퍼짐
- REST 원리를 따르는 시스템을 **RESTful**하다고 부름
- REST의 기본 아이디어는 리소스 즉 자원
    - 자원을 정의하고 자원에 대한 주소를 지정하는 전반적인 방법을 서술
- HTTP 프로토콜을 기반으로 해서 각각의 자원의 식별자와 HTTP 메서드를 사용해서 제한된 인터페이스(환경)에서 클라이언트와 서버 간에 상호작용을 하는 아키텍처 ⇒ 자원 따로, 행동 따로!

### JSON

- JSON is a lightweight data-interchange format
- JavaScript의 표기법을 따른 단순 문자열
- 파이썬의 dictionary, 자바스크립트의 object처럼 C 계열의 언어가 갖고 있는 자료구조로 쉽게 변환할 수 있는 **key-value 형태의 구조**를 갖고 있음
- 사람이 읽고 쓰기 쉽고 기계가 파싱(해석 & 분석)하고 만들어내기 쉽기 때문에 현재 API에서 가장 많이 사용하는 데이터 타입

### REST 정리

- 자원을 정의하고 자원에 대한 주소를 지정하는 방법의 모음
1. 자원을 식별 - **URI**
2. 자원에 대한 행위 - **HTTP Methods**
3. 자원을 표현 - **JSON**
- 설계 방법론은 지키지 않았을 때 잃는 것보다 지켰을 때 얻는 것이 훨씬 많음
    - 단, 설계 방법론을 지키지 않더라도 동작 여부에 큰 영향을 미치지는 않음
    - 말 그대로 방법론일 뿐이며 규칙이나 규약은 아님

> REST - 정보의 자원을 정의(URI)하고 자원에 대한 주소를 지정하는 전반적인 방법을 말함
RESTFUL - REST의 원리를 따르는 시스템을 일컫는 말
> 
> 
> 먼저 REST API에서 API가 무엇인지 확인하고 가자.
> 
> API - 소프트웨어가 다른 소프트웨어로 지정된(정해진) 형식으로 요청 하는 방법 또는 수단을 말한다.
> (API: Application Programming Interface)
> (예> 티비->리모컨(API)->시청자)
> (예> 자판기->자판기버튼(API)->데자와빵 걸린사람)
> 
> REST API - 배달앱 에서 서버에 주문을 넣거나 또는 프론트엔드에서 서버로 데이터를 요청해서 웹서비스를 이용하는 등, 요즘 웹서비스에서 가장 많이 사용하는 정보를 요청하는 방식으로 REST 방식으로 정보를 요청하는 것을 말한다.
> 
> REST 방식이 무엇이고 왜 REST방식으로 정보를 요청하는가?
> 
> 만약에 A라는 개발자와 B라는 개발자가 함께 영화리뷰를 하는 사이트를 만드는데 뒤늦게 C, D라는 개발자도 한 참 뒤에 뒤늦게 투입이 되었다. C, D 개발자가 본 프로젝트에 투입 되기 전,
> A 개발자가 게시판 id가 1인 곳에 영화의 정보를 요청을 보내는 주소를  [https://사이트도메인/1](https://xn--hq1bm8jfyfoxhwa193o/1) 이라고 만들었다고 가정해보자.
> 뒤늦게 투입 된 C, D 개발자는 A가 만들어 놓은 [https://사이트도메인/1](https://xn--hq1bm8jfyfoxhwa193o/1) 주소만 봐서는
> 어떠한 내용을, 무엇을 웹에서 서버로 무엇을 요청하는 api인지 도무지 추측이 안될 것이다. 한번에 알 수가 없을 것이다.
> 
> 그런데 RESTFUL 하게 개발을 한 후에 정보의 요청을 보내는 주소를 예를 들자면
> [https://사이트도메인/comedy/kor/최민식?voterate=5&release=2000](https://xn--hq1bm8jfyfoxhwa193o/comedy/kor/%EC%B5%9C%EB%AF%BC%EC%8B%9D?voterate=5&release=2000) 를 들 수 있다. 요청을 보내는 웹 주소만 보아도 코메디 라는 클래스에 한국영화 중 최민식이 나온 영화 중 조건을 붙여서 평점이 5점이고 개봉일이 2000인 작품의 정보를 요청하고 있구나라고 예측이 가능 할 것이다.
> 
> 정보를 요청할 때 data자원들 예를 들면 kor , voterate 그리고 release 등의 구조와 함께 나타내는 구분자들을 URI라 하고 REST API는 위 예와 같이 정보를 요청할 때만 사용하는 것이 아니라 HTTP method로도 (get post put delete) 요청을 보낸다.
> get-정보읽기(띄우기), post-정보생성(값넣기), put-정보수정(통째로수정), delete-정보삭제
> 
> 따라서 서버로 정보를 요청할 때 요청의 의도를 쉽게 파악할 수 있도록 restful 하게 개발을 해야 한다. 개발에 있어서 RESTFUL 하다라는 것은 REST의 원리 및 설계규칙을 따르는 시스템을 일컫는다.
> REST 설계규칙
> 
> 1. URL은 동사X 명사O 사용한다
> 2. url 마지막에 / 포함하지 않음
> 3. 언더바(_) 사용안하고 하이픈 (-) 사용
> 4. 파일 확장자 예를들어 jpg 등은 URI 에 포함하지 않는다.
> 5. 행위(delete post get put 등)는 URI에 포함하지 않는다. 등이 있다.

## Response

- 다양한 방법으로 JSON 데이터 응답해보기
    1. HTML 응답 → 지금까지 Django로 응답해오던 방식, 더 이상 사용 X
    2. JsonResponse()를 사용한 JSON응답
    3. Django Serializer를 사용한 JSON 응답
    4. **Django REST framework(DRF)를 사용한 JSON 응답**⇒ 앞으로 사용할 것!

### 2. JsonResponse()를 사용한 JSON 응답

- 이제는 문서(HTML) 한 장을 응답하는 것이 아닌 JSON 데이터를 응답해보기
- Django가 기본적으로 제공하는 JsonResponse 객체를 활용하여 Python 데이터 타입을 손쉽게 JSON으로 변환하여 응답 가능
- `**JsonResponse()**`
    - JSON-encoded response를 만드는 클래스
    - `safe` parameter
        - 기본 값 True ⇒ dict인스턴스만 허용
        - False로 설정 시 모든 타입의 객체를 serialization(직렬화)할 수 있음

### 3. Django Serializer를 사용한 JSON 응답

- Django의 내장 `HttpResponse()`를 활용한 JSON 응답
- 2번은 JSON의 모든 필드를 하나부터 열까지 작성해야 했지만 이젠 그렇지 않음

### Serialization

- 직렬화
- 여러 시스템에서 활용하기 위해 데이터 구조나 객체 상태를 나중에 재구성할 수 있는 포맷으로 변환하는 과정. 즉, 어떠한 언어나 환경에서도 **나중에 다시 쉽게 사용할 수 있는 포맷으로 변환하는 과정**
- 변환 포맷은 대표적으로 json, xml, yaml이 있으며 **json**이 가장 보편적으로 쓰임
- Django의 `**serialize()**`는 Queryset 및 Model Instance와 같은 복잡한 데이터를 JSON, XML등의 유형으로 쉽게 변환할 수 있는 Python 데이터 타입으로 만들어 줌

### 4. Django REST framework를 사용한 JSON 응답

- **Django REST framework (DRF)**
- Django에서 RESTful API 서버를 쉽게 구축할 수 있도록 도와주는 오픈소스 라이브러리
- Web API 구축을 위한 강력한 toolkit을 제공
- REST framework를 작성하기 위한 여러 기능을 제공
- DRF의 serializer는 Django의 Form 및 ModelForm 클래스와 매우 유사하게 작동
- djangorestframework를 pip로 설치하고 settings의 INSTALLED_APPS에 rest_framework 추가

### 정리

- DRF를 활용하여 JSON데이터를 응답하는 Django 서버를 구축할 것

## ModelSerializer

- articles/serializers.py 생성

```python
# articles/serializers.py
from rest_framework import serializers
from .models import Article

class ArticleListSerializer(serializers.ModelSerializer):
    class Meta:
        model = Article
        fields = ('id', 'title', 'content', )
```

- ModelSerializer 클래스는 모델 필드에 해당하는 필드가 있는 Serializer 클래스를 자동으로 만들 수 있는 shortcut을 제공
1. Model 정보에 맞춰 자동으로 필드를 생성
2. serializer에 대한 유효성 검사기를 자동으로 생성
3. **`.create()`** 및 `**.update()**`의 간단한 기본 구현이 포함됨

### ModelSerializer의 many option

- 단일 객체 인스턴스 대신 QuerySet 또는 객체 목록을 serialize 하려면 many=True를 작성해야 함

## Build RESTful API - Article

- DRF에서 **`@api_view()`** 데코레이터 작성은 필수

### api_view decorator

- DRF view 함수가 응답해야 하는 HTTP 메서드 목록을 받음
- 기본적으로 GET 메서드만 허용되며 다른 메서드 요청에 대해서는 405 Method Not Allowed로 응답

### GET - Detail

- 단일 게시글 데이터 조회하기
- 각 데이터의 상세 정보를 제공하는 ArticleSerializer 정의
```python
# articles/serializers.py
class ArticleSerializer(serializers.ModelSerializer):
    class Meta:
        Model = Article
        fields = '__all__'
```

## Build RESTful API - Article

### POST

- 게시글 데이터 생성하기
- 요청에 대한 데이터 생성이 성공했을 경우는 201 Created 상태 코드를 응답하고 실패 했을 경우는 400 Bad request를 응답 ⇒ import status
- Postman → Body탭 → form-data → key-value형식 작성

### Raising an exception on invalid data

- 유효하지 않은 데이터에 대해 예외 발생시키기
- is_valid()는 유효성 검사 오류가 있는 경우 ValidationError예외를 발생시키는 선택적 raise_exception 인자를 사용할 수 있음
- DRF에서 제공하는 기본 예외 처리기에 의해 자동으로 처리되며 기본적으로 HTTP 400응답을 반환
- `.is_valid(raise_exception=True)`

### DELETE

- 게시글 삭제하기
- 요청에 대한 데이터 삭제가 성공했을 경우는 204 No Content 상태 코드 응답(명령을 수행했고 더 이상 제공할 정보가 없는 경우)

### PUT

- 게시글 데이터 수정하기
- 요청에 대한 데이터 수정이 성공했을 경우는 200 OK 상태 코드 응답

## Django REST framework - N:1 Relation

- N:1 관계에서의 모델 data를 Serialization하여 JSON으로 변환하는 방법 학습

### Passing Additional attributes to .save()

- save() 메서드는 특정 Serializer 인스턴스를 저장하는 과정에서 추가적인 데이터를 받을 수 있음
- CommentSerializer를 통해 Serialize 되는 과정에서 Parameter로 넘어온 article_pk에 해당하는 article 객체를 추가적인 데이터를 넘겨 저장
- CommentSerializer에서 article field 데이터 또한 사용자로부터 입력 받도록 설정되어 있기 때문에 에러가 나므로 CommentSerializer에 새로운 필드를 설정해줘야 한다.

### 읽기 전용 필드 설정

- **read_only_fields**를 사용해 외래 키 필드를 ‘읽기 전용 필드’로 설정
- 읽기 전용 필드는 데이터를 전송하는 시점에 **해당 필드를 유효성 검사에서 제외시키고 데이터 조회 시에는 출력**하도록 함

## N:1 - 역참조 데이터 조회

1. 특정 게시글에 작성된 댓글 목록 출력하기 ⇒ 기존 필드 override
2. 특정 게시글에 작성된 댓글의 개수 출력하기 ⇒ 새로운 필드 추가

### 1. 특정 게시글에 작성된 댓글 목록 출력하기

- 기존 필드 override - Article Detail
- 게시글 조회 시 해당 게시글의 댓글 목록까지 함께 출력하기
- Serializer는 기존 필드(comment_set)를 override하거나 추가적인 필드를 구성할 수 있음
1. PrimaryKeyRelatedField()
    - models.py에서 **related_name**을 통해 이름 변경 가능 ex)comments같은 이름으로
    - 역참조 시 생성되는 **comment_set**을 override할 수 있음
2. Nested relationships
- 모델 관계 상으로 참조된 대상은 참조하는 대상의 표현에 포함되거나 중첩(nested)될 수 있음
- 이러한 중첩된 관계는 serializers를 필드로 사용하여 표현할 수 있음
- 두 클래스의 상/하 위치를 변경해야 함

### 2. 특정 게시글에 작성된 댓글의 개수 출력하기

- 새로운 필드 추가 - Article Detail
- 게시글 조회 시 해당 게시글의 댓글 개수까지 함께 출력하기
- **source**
    - serializers field’s argument
    - 필드를 채우는 데 사용할 속성의 이름
    - 점 표기법(dotted notation)을 사용하여 속성을 탐색할 수 있음

### 읽기 전용 필드 지정 이슈

- 특정 필드를 override 혹은 추가한 경우 read_only_fields가 동작하지 않으니 주의 ⇒ parameter read_only=True 쓰자

## Django shortcuts functions

### get_object_or_404()

- 모델 manager objects에서 get()을 호출하지만 해당 객체가 없을 땐 기존 DoesNotExist 예외 대신 Http404를 raise함

### get_list_or_404()

- 모델 manager objects에서 filter()의 결과를 반환하고 해당 객체 목록이 없을 땐 Http404를 raise함

### 적용 전/후 비교

- 존재하지 않는 게시글 조회 시 이전에는 500상태코드를 응답했지만 현재는 404 상태코드를 응답
- 클라이언트 입장에서 “서버에 오류 발생하여 요청을 수행할 수 없다(500)”라는 원인이 정확하지 않은 에러를 마주하기 보다는, 서버가 적절한 예외 처리를 하고 클라이언트에게 올바른 에러를 전달하는 것 또한 중요한 요소이기 때문에 사용해야 한다.

## Serializer 활용하기

### to_representation(), 상속 이용하기 등등

- [https://www.django-rest-framework.org/](https://www.django-rest-framework.org/)
