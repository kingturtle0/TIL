# Django

## Framework 이해

- 누군가 만들어 놓은 코드를 재사용하는 것은 이미 익숙한 개발 문화
- 자주 사용되는 부분들을 재사용할 수 있게 좋은 구조의 코드로 만들어져 있다.
- 그러한 코드들을 모아 놓은 것, ****즉 서비스 개발에 필요한 기능들을 미리 구현해서 모아 놓은 것 = 프레임워크****
- “소프트웨어 프레임워크”는 복잡한 문제를 해결하거나 서술하는 데 사용되는 기본 개념 구조
- 소프트웨어의 생산성과 품질을 높인다.

## 클라이언트와 서버

### 클라이언트-서버 구조

- 오늘날 우리가 사용하는 대부분의 웹 서비스는 클라이언트-서버 구조를 기반으로 동작
- 클라이언트와 서버 역시 하나의 컴퓨터이다. 클라이언트는 서버에 요청(requests)하고 서브는 클라이언트에 응답(response)하는 상호작용을 한다.
- 클라이언트
    - 웹 사용자의 인터넷에 연결된 장치(ex. wi-fi에 연결된 컴퓨터 또는 모바일)
    - Chrome과 같은 웹 브라우저
    - **서비스를 요청하는 주체**
- 서버
    - 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터
    - 클라이언트가 웹 페이지에 접근하려고 할 때 서버에서 클라이언트 컴퓨터로 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시된다.
    - **요청에 대해 서비스를 응답하는 주체**
- 어떠한 자원(resource)를 달라고 요청(request)하는 쪽을 클라이언트라고 하고 자원을 제공해주는 쪽을 서버(server)라고 한다.

### 정리

- 우리가 사용하는 웹은 클라이언트-서버 구조로 이루어져 있다.
- Django는 서버를 구현하는 웹 프레임워크이다.

### Django Project

- 설치 : `pip install django==3.2.18`
- 프로젝트 생성 : `django-admin startproject [프로젝트 이름]`
- 서버 실행 : `python [manage.py](http://manage.py) runserver`
- 서버 실행 후 메인 페이지 확인 (ex. [http://127.0.0.1:8000/](http://127.0.0.1:8000/))

### 패키지와 가상환경

각각의 패키지를 하나의 환경에 담아야 한다면? ⇒ 가상환경!

<aside>
💡 **global에 설치하는 것보다는 가상환경을 많이 활용하자!**

</aside>

- 생성 : `python -m venv [venv 가상환경 이름 보통 venv 사용]`
- 활성화 : `source venv/Scripts/activate`
- 비활성화 : `deactivate`
- 가상환경 패키지 목록 저장 : `pip freeze > requirements.txt`
- 파일로부터 패키지 설치 : `pip install -r requirements.txt`

## 프로젝트와 앱

- 장고는 커다란 프로젝트 하나와 기능 단위의 여러 앱으로 이루어져 있다.

### 프로젝트 구조

- _ _init _ _.py
- asgi.py
- settings.py
    - Django 프로젝트 설정을 관리
- urls.py
    - 사이트의 url과 적절한 views의 연결을 지정
- wsgi.py
- manage.py
    - Django 프로젝트와 다양한 방법으로 상호작용하는 커맨드라인 유틸리티

### Django Application

- 앱 생성 : `python [manage.py](http://manage.py) startapp articles` 앱 이름은 복수형으로 작성 권장
앱(App) == 하나의 큰 기능 단위
정해진 규칙은 없으며 개발자가 판단해서 앱 생성
여러 개의 앱이 아닌 단일 앱으로 개발해도 괜찮다.

### 앱 구조

- [admin.py](http://admin.py)
    - 관리자용 페이지를 설정하는 곳
- apps.py
- models.py
    - 앱에서 사용하는 Model(데이터 구조)을 정의하는 곳
    - MTV패턴의 M에 해당
- tests.py
- view.py
    - 앱의 로직을 적는 곳. view 함수들이 정의 되는 곳
    - MTV패턴의 V에 해당

### 앱 등록

<aside>
💡 **앱을 사용하기 위해서는 반드시 INSTALLED_APPS 리스트에 앱을 추가해야한다.**

</aside>

### Project & Application

- Project
    - collection of apps, 프로젝트는 앱의 집합
    - 프로젝트에는 여러 앱이 포함될 수 있다.
    - 앱은 여러 프로젝트에 있을 수 있다.
- Application
    - 앱은 실제 요청을 처리하고 페이지를 보여주는 등의 역할을 담당
    - 앱은 하나의 역할 및 기능 단위로 작성하는 것을 권장한다.

## 요청과 응답

### Django의 세가지 구조, MTV

- Model
- View
- Template ⇒ html!

### URLs

- URL → VIEW → TEMPLATE 데이터 흐름 이해하기

### View

- 실행시킬 함수를 적는 곳
- 요청이 들어오면 HTML Page로 응답을 돌려준다.

### Templates

- 실제 내용을 보여주는데 사용되는 파일
- 파일의 구조나 레이아웃을 정의
- Template 파일의 기본 경로
    - app 폴더 안의 templates 폴더
    - **app_name/templates/app_name**

<aside>
💡 **템플릿 폴더 이름은 반드시 templates로 지정.
app_name/templates/app_name 위치에 html생성**

</aside>

### render()

`render(request, template_name, context)`

- 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링된 텍스트와 함께 HttpResponse(응답) 객체를 반환하는 함수
1. request : 응답을 생성하는 데 사용되는 요청 객체
2. template_name : 템플릿의 전체 이름 또는 템플릿 이름의 경로
3. context : 템플릿에서 사용할 데이터 (딕셔너리 타입으로 작성)

### 코드 작성 순서

- 앞으로 Django에서의 코드 작성은 URL → View → Template순으로 작성(”데이터의 흐름 순서”)

```python
# settings
INSTALLED_APPS = []  # <= APP이름 추가
# URL
from APP_NAME import index
path('index/', views.index)
# View
def index(request):
    return render(request, 'index.html')
# Template 
# APP_NAME/templates/APP_NAME/index.html에 만들기
```

## Django 구조 이해하기(MTV Design Pattern)

### Design Pattern(SW 관점)

- 각기 다른 기능을 가진 다양한 응용 소프트웨어를 개발할 때 공통적인 설계 문제가 존재하며, 이를 처리하는 해결책 사이에도 공통점이 있다는 것을 발견. 이런 유사점을 패턴이라 한다.
- 클라이언트-서버 구조도 소프트웨어 디자인 패턴 중 하나이다. 목적은 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책을 제시하는 것이다.

<aside>
💡 다수의 엔지니어들이 일반화된 패턴으로 소프트웨어 개발을 할 수 있도록 한 규칙, 커뮤니케이션의 효율성을 높이는 기법

</aside>

## Django’s Design Pattern

- Django에 적용된 디자인 패턴은 **MTV패턴**이다.
- MTV패턴은 **MVC 디자인 패턴**을 기반으로 조금 변형된 패턴이다.

### MVC SW Design Pattern

- MVC는 Model - View - Controller의 준말이다. 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴
- 하나의 큰 프로그램을 세가지 역할로 구분한 개발 방법론
1. Model : 데이터와 관련된 로직을 관리
2. View : 레이아웃과 화면을 처리
3. Controller : 명령을 model과 view 부분으로 연결

### MVC SW Design Pattern 목적

- 관심사 분리
- 더 나은 업무의 분리와 향상된 관리 제공
- 각 부분을 독립적으로 개발 가능(하나씩 수정 가능) == 개발 효율성 및 유지보수가 쉬워짐 == 다수의 멤버로 개발하기 용이

### Django에서의 디자인 패턴

- Django는 MVC패턴을 기반으로 한 MTV패턴을 사용한다. 두 패턴은 서로 크게 다른 점은 없으며 역할에 대해 부르는 이름이 다르다.

| MVC | MTV |
| --- | --- |
| Model | Model |
| View | Template |
| Controller | View |

### MTV 디자인 패턴

- Model
    - MVC 패턴에서 Model의 역할에 해당
    - 데이터와 관련된 로직을 관리
    - 응용프로그램의 데이터 구조를 정의하고 데이터베이스의 기록을 관리
- Template
    - MVC 패턴에서 View의 역할에 해당
    - 레이아웃과 화면을 처리
    - 화면상의 사용자 인터페이스 구조와 레이아웃을 정의
- View
    - MVC 패턴에서 Controller의 역할에 해당
    - Model & Template과 관련한 로직을 처리해서 응답을 반환
    - 클라이언트의 요청에 대해 처리를 분기하는 역할
    - 예시 : 데이터가 필요하다면 model에 접근해서 데이터를 가져오고 가져온 데이터를 template로 보내 화면을 구성하고 구성된 화면을 응답으로 만들어 클라이언트에게 반환

### 정리

- Model : 데이터 관련
- Template : 화면 관련
- View : Model & Template 중간 처리 및 응답 반환

## Django Template

- 데이터 표현을 제어하는 도구이자 표현에 관련된 로직
- Django Template을 이용한 HTML 정적 부분과 동적 컨텐츠 삽입
- Template System의 기본 목표를 숙지
- Django Template System : 데이터 표현을 제어하는 도구이자 표현에 관련된 로직을 담당

### Django Template Language(DTL)

- Django template에서 사용하는 built-in template system
- 조건, 반복, 변수 치환, 필터 등의 기능을 제공
    - Python처럼 일부 프로그래밍 구조(if, for 등)를 사용할 수 있지만 이게 **Python 코드로 실행되는 것이 아니다.**
    - Django Template System은 단순히 python이 HTML에 포함된 것이 아니니 주의
- 프로그래밍적 로직이 아니라 프레젠테이션을 표현하기 위한 것임을 명심할 것

### DTL Syntax

1. Variable : 변수
2. Filters : 변수가 보여지는 걸 바꿔주는 것
3. Tags : 변수보다 복잡한 일
4. Comments : 주석

### Variable `{{variable}}`

- 변수명은 영어, 숫자와 밑줄(_)의 조합으로 구성될 수 있으나 밑줄로는 시작할 수 없다.(공백이나 구두점 문자도 불가)
- dot(.)를 사용하여 변수 속성에 접근할 수 있다.(리스트 인덱스 및 딕셔너리 키 값에 접근 가능)
- render()의 세 번째 인자로 {’key’:value}와 같이 딕셔너리 형태로 넘겨주며, 여기서 정의한 key에 해당하는 문자열이 template에서 사용 가능한 변수명이 된다.

### Filters `{{variable|filter}}`

- 표시할 변수를 수정할 때 사용(값이 바뀌는 게 아니다)
- 60개의 built-in template filters를 제공(공식문서 확인)
- chained가 가능하며 일부 필터는 콜론으로 인자를 받기도 한다.

### Tags `{% tag %}`

- 출력 텍스트를 만들거나, 반복 또는 논리를 수행하여 제어 흐름을 만드는 등 변수보다 복잡한 일들을 수행
- 일부 태그는 시작과 종료 태그가 필요 `{% if %}{% endif %}`
- 24개의 built-in template tags를 제공한다.

### Comments `{# #}`

- Django template에서 라인의 주석을 표현하기 위해 사용
- 한 줄 주석에만 사용할 수 있다.(줄 바꿈 X)
- 여러 줄 주석은 `{% comment %}`와 `{% endcomment %}` 사이에 입력

## Template inheritance

### 템플릿 상속

- 템플릿 상속은 기본적으로 코드의 재사용성에 초점을 맞춤
- 템플릿 상속을 사용하면 사이트의 모든 공통 요소를 포함하고, 하위 템플릿이 재정의(override)할 수 있는 블록을 정의하는 기본 ‘skeleton’ 템플릿을 만들 수 있음

### 템플릿 상속에 관련된 태그

`{% extends ‘’ %}`

- 자식(하위) 템플릿이 부모 템플릿을 확장한다는 것을 알림

<aside>
💡 반드시 템플릿 최상단에 작성 되어야 한다. 즉, 2개 이상 사용할 수 없다.

</aside>

`{% block content %}{% endblock content %}`

- 하위 템플릿에서 재지정(overridden)할 수 있는 블록을 정의
- 즉, 하위 템플릿이 채울 수 있는 공간

### Django의 Template 처리

- settings.py에서 TEMPLATES 리스트를 보면 `'APP_DIRS':True`로 app별로 디렉토리를 두는 것으로 되어 있다.
- `'DIRS':[]` 부분에 디렉토리를 적어주면, Django가 해당 디렉토리부터 확인한다. ⇒ 모든 앱에서 가져다 쓸 수 있다.

<aside>
💡 DIRS에 디렉토리를 적어주기 전에는 base.html이 app안의 templates이므로 
`{% extends './base.html' %]` 와 같이 적었지만 app의 템플릿에서 프로젝트의 템플릿으로 옮기면 `{% extends 'base.html' %]` 로 사용하면 된다.

</aside>

## Django URLs

### Trailing URL Slashes

- Django는 URL 끝에 /(Trailing slash)가 없다면 자동으로 붙여주는 것이 기본 설정이다.
    - 모든 주소가 ‘/’로 끝나도록 구성되어 있다.
    - 모든 프레임워크가 이렇게 동작하는 것은 아니다.
- Django의 url 설계 철학 [foo.com/bar](http://foo.com/bar) 와 [foo.com/bar/](http://foo.com/bar/는)는 서로 다른 URL이다.
    - 검색 엔진 로봇이나 웹 트래픽 분석 도구에서는 그 둘을 서로 다른 페이지로 본다.
    - 그래서 Django는 URL을 정규화하여 검색 엔진 로봇이 혼동하지 않게 해야한다.

### Variable routing

- 템플릿의 많은 부분이 중복되고, 일부분만 변경되는 상황에서 비슷한 URL과 template을 만드는 것을 방지하기 위해 필요하다.
- URL 주소를 변수로 사용하는 것을 의미
- URL의 일부를 변수로 지정하여 view 함수의 인자로 넘길 수 있다.
- 즉, 변수 값에 따라 하나의 path()에 여러 페이지를 연결시킬 수 있다.
- 변수는 ‘<>’안에 정의하며 view함수의 인자로 할당된다.
- 기본 타입은 string이며 5가지 타입으로 명시할 수 있다.
    1. str `urlpatterns=[path('hello/<str:name>/', views.hello),]`
        - ‘/’를 제외하고 비어 있지 않은 모든 문자열
        - 작성하지 않을 경우 기본 값
    2. int
        - 0 또는 양의 정수와 매치
    3. slug
    4. uuid
    5. path

### View 함수 작성

- variable routing으로 할당된 변수를 인자로 받고 템플릿 변수로 사용할 수 있다.

## App URL mapping

- App이 많아지면? 모두 프로젝트의 urls.py에서 관리하기 힘들고 가독성도 떨어진다.
- 같은 이름이 겹친다면 view함수를 as문법으로 다른 이름으로 import할 수 있겠지만 역시 많아질수록 비효율적이다.
- 간단하다, urls.py를 쪼개면 된다.
- 하나의 프로젝트에 여러 앱이 존재한다면, 각각의 앱 안에 urls.py를 만들고 프로젝트 urls.py에서 각 앱의 urls.py파일로 URL매핑을 위탁할 수 있다.
- **각각의 app 폴더 안에 urls.py를 작성한다.**

### Including other URLconfs

- urlpattern은 언제든지 다른 URLconf모듈을 포함(include)할 수 있다.

<aside>
💡 **include되는 앱의 urls.py에 urlpatterns가 작성되어 있지 않다면 에러가 발생한다. 예를 들어 pages 앱의 urlpatterns가 빈 리스트라도 작성되어 있어야 한다.**

</aside>

### include()

- 다른 URLconf(app/urls.py)들을 참조할 수 있도록 돕는 함수
- 함수 include()를 만나게 되면 URL의 그 시점까지 일치하는 부분을 잘라내고, 남은 문자열 부분을 후속 처리를 위해 include된 URLconf로 전달

## Naming URL patterns

- 만약 index/의 문자열 주소를 new-index/로 바꿔야 한다고 가정하자. index/ 주소를 사용했던 모든 곳을 찾아서 변경해야 하는 번거로움이 발생한다.

### Naming URL patterns

- 이제는 링크에 URL을 직접 작성하는 것이 아니라 path()함수의 name인자를 정의해서 사용한다.
- DTL의 Tag 중 하나인 URL 태그를 사용해서 path()함수에 작성한 name을 사용할 수 있다.
- 이를 통해 URL 설정에 정의된 특정한 경로들의 의존성을 제거할 수 있다.
- Django는 URL에 이름을 지정하는 방법을 제공함으로써 view함수와 템플릿에서 특정 주소를 쉽게 참조할 수 있도록 도움

### Built-in tag-”url” `{% url “” %}`

- 템플릿에서 사용하기
- 주어진 URL패턴 이름 및 선택적 매개 변수와 일치하는 절대 경로 주소를 반환
- 템플릿에 URL을 하드 코딩하지 않고도 DRY원칙을 위반하지 않으면서 링크를 출력하는 방법

### url태그 출력 확인하기

- 마지막으로 개발자 도구를 통해 url태그가 URL 패턴 이름과 일치하는 절대 경로 주소를 반환하는 것을 확인해보기

## URL namespace

- URL namespace를 사용하면 서로 다른 앱에서 동일한 URL 이름을 사용하는 경우에도 이름이 지정된 URL을 고유하게 사용할 수 있다.
- **app_name** attribute를 작성해 URL namespace를 설정

### URL tag의 변화

`{% url 'index' %}` ⇒ `{% url 'articles:index' %}`

위와 같이 “:”연산자를 사용하여 지정하는 것이 URL 참조이다.

### 기존 URL tag 변경

<aside>
💡 **app_name을 지정한 이후에는 url 태그에서 반드시 app_name:url_name 형태로만 사용해야 한다. 그렇지 않으면 NoReverseMatch에러가 발생한다.**

</aside>
